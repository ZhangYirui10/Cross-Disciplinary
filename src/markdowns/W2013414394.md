# On Triangulation-based Dense Neighborhood Graph Discovery

# Nan Wang, Jingbo Zhang, Kian-Lee Tan, Anthony K. H. Tung

# School of Computing, National University of Singapore, Singapore

{wangnan, jingbo, tankl, atung}@comp.nus.edu.sg

# ABSTRACT

This paper introduces a new definition of dense subgraph pattern, the DN-graph. DN-graph considers both the size of the substructure and the minimum level of interactions between any pair of the vertices. The mining of DN-graphs inherits the difficulty of finding clique, the fully-connected subgraphs. We thus opt for approximately locating the DN-graphs using the state-of-the-art graph triangulation methods. Our solution consists of a family of algorithms, each of which targets a different problem setting. These algorithms are iterative, and utilize repeated scans through the triangles in the graph to approximately locate the DN-graphs. Each scan on the graph triangles improves the results. Since the triangles are not physically materialized, the algorithms have small memory footprint.

With our solution, the users can adopt a “pay as you go” approach. They have the flexibility to terminate the mining process once they are satisfied with the quality of the results. As a result, our algorithms can cope with semi-streaming environment where the graph edges cannot fit into main memory. Results of extensive performance study confirmed our claims.

# 1. INTRODUCTION

Graphs are the most pervasive model of entity interactions as it concisely captures the interactions among entities. However, for large graphs (which are becoming increasingly common in many applications), it becomes too complicated for human beings to find key information without the help of suitable graph mining technology. Graph mining refers to the process of discovering designated subgraphs from a target graph, in the hope of uncovering unknown knowledge about the graph. When facing unsolvable resource constraint, how to answer the mining question to the best, becomes more challenging.

Most recent works on graph mining believe that dense patterns are prominent. They capture the most active involvement of entity interactions. Subsequently, researchers propose various definitions of dense substructures. In section 2, we review some of these patterns. Intuitively, a dense pattern contains a set of highly relevant vertices. They usually share a large number of common neighbors (two vertices are neighbors if they connect to each other by an edge). The definition of DN-graph (a.k.a. Dense Neighborhood graph) follows this intuition.

This paper provides a set of algorithms to mine DN-graphs from large scaled graphs. The problem of mining DN-graphs is an NP-complete problem (due to the close relationship between DN-graphs and cliques, lemma 3.1 will cover this in detail). As such, in this paper, we opt to design approximate solutions. In our solutions, the local neighborhood size is the most important, but difficult, quantity to be computed. We associate this quantity with local triangle counting in order to approximate it efficiently.

Graph triangulation refers to the process of generating all triangles in a graph. Our approach locates DN-graph by using the state-of-the-art triangulation algorithm. As the storage of triangles can be expensive, we do not store these triangles. Instead, we design our approach to operate iteratively. In each iteration, our scheme dynamically regenerates all triangles and improves the connectivity estimation between vertices in each round.

Such an iterative, triangulation-based approach has three advantages. Firstly, most of the details involved in efficient processing, such as minimizing I/Os, are abstracted within the triangulation algorithm. The abstraction ensures our approach’s extensibility to different input settings, e.g. when the target graph is too large to fit into memory, our approach only needs to change the access method of the graph links. In addition, the estimation of the local neighborhood is encapsulated within the triangulation algorithm. Secondly, as the estimation of the local density value improves with each additional iteration, users can adopt a “pay as you go” approach and obtain the most updated results on demand. Finally, when the graph is too large to fit into the main memory, we can collect statistics in the first iteration to support effective buffer management, should there be a need to store the local density value on a disk, since the triangles are generated in the same ordering in every iteration.

In this paper, we present triangulation based dense graph mining algorithms. Together they form an algorithm family. Their key features are compared in Table 1. For brevity, we name them respectively as 1) TriDN, 2) BiTriDN and 3) StreamDN. Algorithms TriDN and BiTriDN are two variances that handle in-memory graphs. Both algorithms iteratively generate triangles to refine the λ value. These two processes reach convergence when all λ values remain the same as previous iteration. The third algorithm, StreamDN, is for semi-streaming graph setting. In section 4.2, we introduce the model of semi-streaming.

Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Articles from this volume were invited to present their results at The 37th International Conference on Very Large Data Bases, August 29th - September 3rd 2011, Seattle, Washington.

Proceedings of the VLDB Endowment, Vol. 4, No. 2 Copyright 2010 VLDB Endowment 2150-8097/10/11... $ 10.00.

|In|Time|Space| |
|---|---|---|---|
|TriDN|Yes|O(klog|V||E|3)|O(|V|log|V|2 + |E|)|
|BiTriDN|Yes|O(klog|V||E|2)|O(|V|log|V| + |E|)|
|StreamDN|No|O(k|E|)|O(|V|)|

Table 1: A Family of DN-Graph Mining Algorithms

To mine semi-streaming graphs, algorithm StreamDN applies the min-wise independent set property, which provides an approximation for triangulation using sequentially scan of graph edges, with bounded error.

The rest of the paper is organized as follows: In Section 2, we review related works. The definition of DN-graph is formally presented in Section 3. We present algorithms for finding DN graphs in Section 4. Experimental studies are then described in Section 5. Section 6 concludes our work.

# 2. RELATED WORK

A dense graph pattern is a connected subgraph that has significantly more internal connections with respect to the surrounding vertices. Depending on the semantic meanings of the graph data, various forms of dense patterns have been investigated in the literature.

1.  Clique/Quasi-Clique. A clique represents the highest level of internal interactions. In graph theory, a clique is a fully connected subgraph. Each pair of vertices are connected by an edge. A quasi-clique, on the other hand, is an “almost” clique with a few missing edges. If a clique is not a proper subgraph of any larger clique, we call it a “closed” clique.
2.  High Degree Patterns. This pattern requires the average vertex degree to be above certain level or outstanding among surrounding vertices. Here a vertex’s degree is the number of edges intercepting the vertex. Unlike cliques, a high degree pattern do not require high interconnection within the pattern [8].
3.  Dense Bipartite Patterns. If the involved entities belong to two distinctive classes, and only entities from different classes have associations, the dense bipartite patterns are bipartite graphs with outstandingly many edges.
4.  Heavy Patterns. Previous patterns emphasize on the topological features. The heavy patterns, however, aim at maximizing edge weights [9]. If the weights on the edges of a weighted graph follow the triangle inequality, the heavy pattern is also a dense pattern in the un-weighted graph. Even though this type of pattern is not our preliminary target for this paper, it is presented here for completeness purpose.

In this paper, we view a dense subgraph as a set of vertices sharing many common neighbors. If two connected vertices share one common neighbor, they form a triangle together with their common neighbor. In view of the association between dense patterns and triangles, we further study the problem of triangle counting.

Triangle counting and listing have been well studied in the literature. Given a graph G with |V| vertices and |E| edges, [14] proposed a triangle-listing algorithm with time complexity O(|E|3) and with O(3|E| + 3|V|) space. Further work [13] improves the performance of the algorithm by separating the vertices into two types, dense and sparse. The improved technique has the same time complexity as the work in [14], while it reduces the space complexity to O(|E| + |V|). The above ideas count triangles by scanning graph edges, and join adjacency list of the two vertices. The scanning of graphs makes these techniques highly adaptable to streaming environment (In section 4.2, we discuss the graph streaming model.).

Other research works on mining dense subgraphs can be classified according to their counterparts in item-set mining approaches. The most relevant work is the density based solution [15]. This work provides not only a way to find the closed cliques (biggest clique among the neighborhood) but to order all graph vertices into a linear fashion for visualization purpose. One of the leading approaches in [8] adopts two-level-shingling method. Although the work only demonstrates its power in collecting statistics from extremely large graph, its performance is impressive and this approach can be employed into graph mining domain to handle large scale graphs.

# 3. DN-GRAPH AS A DENSITY INDICATOR

A graph G(V, E) consists of a set of vertices V and set of interactions E over V × V. The size of G, denoted as |V|, is the number of vertices in V. The neighborhood of a graph vertex v, is the set of vertices directly connecting to v. We use N(v) to represent it. If vertex u and v share some common neighbors, we use N∩(u, v) to represent the joint neighborhood. The neighborhood of e is the joint neighborhood of its two end vertices. We denote the joint neighborhood as Nₑ. For a subgraph G′ of G, the neighborhood of G′, N(G′), is the set of vertices u ∈ G \ G′, which immediately connect with vertices in G′. Inside a graph, the measurement of minimal joint neighborhood size between any connected vertex pair is denoted as λ. We use the notation λ(G)/λ(V) to refer to the measurement of a graph G with vertex set V. For brevity, we omit the content inside bracket and use λ when the context is clear. We also use ˜a to represent an upperbound of quantity a. The upper-bound of λ is thus written as ˜λ.

In this paper, a clique is a fully connected graph, in which every pair of vertices are connected by an edge. If the size of a clique is c, we call the clique a c-clique. When compared with clique of the same size, a quasi-clique has only a fraction (say δ) of edges in the graph, it is a δ quasi-clique. Conventionally δ is in the interval (0.5, 1].

# DEFINITION 1. DN-Graph

A DN-graph with parameter λ, denoted G′(V′, E′, λ), is a connected subgraph G′(V′, E′) of graph G(V, E) that satisfies the following conditions: (1) Every connected pair of vertices in G′ share at least λ common neighbors. (2) for any v ∈ V \ V′, λ(V′ ∪ {v}) < λ; and for any v ∈ V′, λ(V′ − {v}) ≤ λ.

As the definition states, a DN-graph should be a connected subgraph in which the lower bound of shared neighborhood between any connected vertices, λ, is locally maximized. Being a DN-graph, it has local maximal λ value and the size of the DN-graph is maximized. This ensures that the DN-graph has more distinguishing power and maximal coverage. Similar with the graph’s diameter and minimum cut, λ is an indicator of the graphs’ underlying density. As proven in the appendix (Proposition 8.3), it is a local maximum graph. For example, in figure 1, subgraph ABCDEF is a DN-graph of λ value 3. If we include one more vertex A′, the λ value of the graph A′ABCDEF’s drops significantly to 0.

Similarly, taking away any vertex, say A, leads to a lower value λ. DN-graph is designed to represent dense patterns, as it captures subgraphs with more internal associations. It is thus not surprising to see the correlation between DN-graph’s λ value and maximum clique size, which is another popular dense indicator. Figure 2 illustrates the relationship between λ and the size of the maximum clique within a dynamic graph. The graph consists

Generally speaking, the level of interactions among entities determines the density of the substructures. From this point of view, it is not surprising to see that some patterns are transformable to others. For example, a DN-graph is a more general case of a closed clique (Recall that a clique is a fully connected graph, while the closed clique is the local maximal clique). In fact, a DN-graph is a relaxation of a clique, with less rigid size constraints. Lemma 3.1 states the relationship formally:

# Figure 1: A DN-Graph

# LEMMA 3.1. DN -Graph and Closed Clique

A graph contains a closed clique of size d if and only if the graph contains a DN-graph g with λ = d− 2 and |g| = d.

The proof of above lemma is explained in detail in appendix 8.2. Here we omit it for brevity. Using Lemma 3.1, we are able to reduce the close clique mining problem to DN-graph mining problem. The reduction signifies that DN-graph mining is NP-complete (detail please refer to appendix 8.4). Prompted by this result, we seek to develop heuristical solutions instead.

Like the closed clique mining problem, the computational bottleneck for DN-graph mining is on counting degrees within a subgraph. In fact, the counting of local degrees relies heavily on the multiple joins of neighbors, which are computationally expensive. To avoid the complexity of multiple joins, we next introduce the concept of λ(e).

# 3.1 DN-Graph and λ(e)

As discussed previously, the bottleneck of DN -graph mining is excessive number of neighborhood joins required. This is because we have to test combinatorial number of subgraphs for their λ value and most subgraphs tested are not DN-graphs.

Most of λ value testings however are unnecessary. Due to the local maximality feature of a DN -graph, it is impossible for any two different DN-graphs to share any common vertices or edges. Once we verify that a graph, g is a DN-graph, we need not consider other subgraphs that intercept with gdn. In fact, by computing the λ value of edges, we can locate DN -graphs. If we assign the λ value of gdn as the density value of its edges, a DN-graph becomes a set of edges with local maximal λ.

# DEFINITION 2. DN-graph mining problem

Given a graph G(V, E), we want to find all DN -graphs g(v, e, λ) in G.

# DEFINITION 3. λ(e)

Given a graph G(V, E) and an edge e ∈ E, λ(e) is the maximal λ(G′) value where e ∈ E(G′) and G′ ⊆ (G).

|18|whole‐Graph| | | | | | |
|---|---|---|---|---|---|---|---|
|15|dense‐Graph| | | | | | |
|12|sparse‐Graph| | | | | | |
|9|λ| | | | | | |
|6| | | | | | | |
| | | |3| | | | |
|0|0|30|60|90|120|150|180|

# THEOREM′ 3.1. Locating DN-Graph Using λ(e)

A graph G is a DN-graph if and only if

- all edges e within G′ have equal λ(e) value, represented as λmax and,
- for all u ∈ N(G′) and v ∈ G′, λ(u, v) ≤ λmax.

For a proof of Theorem 3.1, readers are referred to Appendix 8.3. Based on Theorem 3.1, we can locate the DN-graph by connecting edges with local maximal λ(e).

# Figure 2: The Growth in λ Value of a 20-Vertex Dynamic Graph

Computing λ(e) for all edges is however computationally prohibitive, as discussed in section 3. To facilitate approximation efficiently, we first find an upper bound value for λ(e), the ˜λ(e), and

then iteratively reﬁne ˜ λ(e) to capture the actual λ(e) as accurately as possible. The approximation is based on the fact that for an edge e, its λ(e) value is upper bounded by the joint neighborhood size of the end vertices of e. This joint neighborhood size is in fact the number of triangles e participates in a graph. Thus we are inspired to use triangulation to approximate λ(e) for every graph edge.

# 4. LOCAL TRIANGULATION AND ITS APPLICATION IN DN-GRAPH MINING

A triangle consists of a vertex triple (u, v, w) and three edges (u, v), (v, w) and (u, w). The problem of counting or listing all triangles within a graph is referred as Graph Triangulation in this paper:

# DEFINITION 4. Graph Triangulation

Given a graph G(V, E), Graph Triangulation ﬁnds all vertex triples (u, v, w), where every vertex pair inside the triple are connected by an edge, denoted as e(u, v), e(v, w) and e(u, w) respectively.

The joint neighborhood of an edge e(u, v) upper-bounds λ(e), while the number of triangles e(u, v) participates in is equal to the joint neighborhood size. This indicates that graph triangulation provides an upper bound λ(e) for every edge e. Here we use ˜ λ(u, v) to represent the current upper bound of edge (u, v). What’s more, given a graph triangle, the ˜ λ(u, v) can tighten the other two edges’ density upper bound. The following proposition gives the relationship between an edge ˜ e’s (λ(e)) and its neighbors’:

# P 4.1. Neighbor Bounding of ˜ λ(e)

ROPOSITION ˜ λ(e) Inside a triangle (u, v, w), if λ(u, v) ≤ min(˜ λ(u, w), λ(v, w)), we say w supports ˜ λ(u, v). λ(u, v) is valid if and only if |{w|w supports λ(u, v)}| ≥ ˜ λ(u, v).

PROOF. The proof of necessary condition for proposition 4.1 follows the deﬁnition of the ˜ λ value and is omitted for brevity. Now we prove the sufﬁcient condition: If the number of supporting vertices is greater or equal to ˜ λ(e), then λ(e) is an upper bound for ˜ λ(e). We prove this by contradiction. Suppose there are fewer than λ(e) supporting vertices for ˜ λ(e), according to the deﬁnition of λ(e), λ(e) < λ(e), which means in that case, ˜ λ(e) is larger than λ(e). This contradicts with earlier assumption. With the above reasoning, we complete the proof of proposition 4.1.

# 4.1 Triangulation Based DN-Graph Mining

The elementary operation behind local triangulation is the joining of vertex neighborhoods. As studied in [13], the performance of a local triangulation algorithm heavily depends on the order of those join operations. In fact, it is a necessary preprocessing step to sort vertices according to their degrees for effective triangulation (Appendix 8.5 will explains the algorithm in detail).

# 4.1.1 Generate Triangles to Reﬁne Local Density

We adopt the graph triangulation algorithm in [13]. The algorithm generates triangles systematically for each edge of the graph. The generation of the triangles is a sequence of join operations between the neighbors of two connected vertices. Based on a special order of joining operations, the triangles are generated in a streaming fashion. The DN-graph mining algorithm thus obtains the local density information gradually along the triangle streams. Based on proposition 4.1, we can use the number of triangles an edge participates in (T C(e)) as the initial upper bound of the λ(e), the ˜ λ(e). To give an even more accurate bound for λ(e), the algorithm uses the density value of e’s neighbors’ to validate the current upper bound λ(e). Figure 3 shows how this process works graphically.

In the ﬁrst round of graph triangulation, we are aware of the triangular count of e(a, b) (which is in fact ˜ λ(e)), and nothing about its neighbors. However, the triangular counts of the neighbors (a.k.a local density estimation) are available once the ﬁrst round of graph triangulation is completed. To compute a more accurate ˜ λ(e) for each edge, we will simply go through more rounds of triangulation and make use of the density information of the neighbors to further validate a new estimation of ˜ λ(e) for each edge.

For a triangle (a, b, n1), the algorithm checks whether the triangle can possibly be a supporting evidence that edge e(a, b) is in a DN-graph, with ˜ λ(e). This is done by checking whether both the other two edges of triangle (a, b, n1) (i.e. e(a, n1) and e(b, n1)) have ˜ λ greater or equal to λ(e). If this is the case, this means that n1 is such a supporting vertex.

The triangle is then represented as a solid line indicating that e(a, b) finds a new supporting vertex n1 in DN-graph with ˜ λ(e). As new triangles approach, the algorithm counts the number of supporting vertices for edge (a, b) to form DN-graph, with current value of ˜ λ(e). After one pass of all triangles, the number of vertices that support each edge’s density upper bound ˜ λ(e) are available for further computation.

# Algorithm 1 Triangulation based DN-Graph Mining

Require: Graph G(V, E)

1: Triangles = Triangulation(G), k(e)=Triangle count(e)
while converge AND iteration!=MAX ITR do
sc = 0, converge=TRUE

for all Triangles (a, b, c) ∈ G do
Increment corresponding sc(e) if e is supported
end for
for all edges e ∈ G do
if (sc(e) < ˜ λ(e)) then
Find next possible value ˜ λ(e) for e
converge = FALSE
end if
end for

Increment iteration by 1
end while
return ˜ λ(e) for each e ∈ E

With the supporting neighbors’ information, the algorithm is able to determine the upper bound of λ for each graph edge (the upper bound is denoted as ˜ λ(e)). If sufficient supporting vertices are found for λ(e) for an edge e(a, b), ˜ λ(e) is a valid upper bound of e(a, b)’s λ value. If there is not enough supporting vertices for e(a, b), the algorithm finds the next possible ˜ λ(e) value and tests it in the next round of triangulation. The algorithmic description is given in Algorithm 1. Within the algorithm, sc(e) records the number of vertices supporting current ˜ λ(e) value.

# 4.1.2 λ(e) Bounding Choice

We can derive two variants of DN-graph mining algorithms from Algorithm 1, namely algorithms TriDN and BiTriDN. The two algorithms have different ways to decide the next possible ˜ λ(e) value. The first variant, called TriDN, decreases ˜ λ(e) by one (Line 9 in Algorithm 1 becomes λ(e) = λ(e)−1), if current ˜ λ(e) cannot obtain sufficient supporting vertices count. This strategy is useful when the triangle counts are close to the actual λ(e) values (qualitatively, when |T C(e) + 2 − λ(e)| ≤ logλ(e)).

# 4.2 Extension of DN-Graph Mining to Semi-Streaming Graph

The semi-streaming graph model assumes the vertices of the graph can be fitted into main memory, and the interactions among vertices are stored in an ordered manner within the secondary storage. While this assumption may not hold for arbitrarily large graphs, we can still handle up to Giga scale vertices (assume |V| vertices require |V|log|V| bits storage) with today’s main memory capacities. Following the nature of physical storage devices, our streaming model assumes random access in primary storage (i.e. memory) and only sequential access in secondary storage. In the secondary storage, graph interactions are stored in the form of adjacency list. As a feasible solution towards a streaming graph G(V, E), it should not exceed log|V| scans of G’s adjacency list.

In the semi-streaming graph setting, the exact triangulation algorithm proposed in [13] cannot be directly applied in the DN-graph mining solutions. The information of the neighbors are stored in secondary storage and may not be immediately available when the algorithm retrieves it.

In view of above difficulty, our streaming solution first performs a semi-streaming triangulation, followed by the complete DN-graph mining solution in semi-streaming setting.

The neighborhoods join operations are in fact the process of determining the similarity between two sets. The most well-adapted measurement for set similarity is Jaccard coefficient. For two sets A and B, Jaccard coefficient is calculated as J(A, B) = |A∩B| / |A∪B|.

In the semi-streaming graph setting, it is however expensive to calculate Jaccard coefficient between two neighborhoods. Since the operation of set joining requires expensive pre-processing of sets such as sorting or heap building.

In view of above difficulty, we use the property of min-wise independent set to approximate Jaccard coefficient. When dealing with large sets, min-wise independent property approximate set intersection size using sequential scan only.

Suppose A and B are defined on the set universe X, and π is a permutation over universe X, the min-wise independent property states: If π[X] is a uniformly chosen random permutation over X, and W ⊂ [X] is any subset over the universe, and π[W] is the projection of W by permutation π, then the probability that two subsets’ minimal projected images are equal is the same as the Jaccard coefficient. Formally, P[min(π[A]) == min(π[B])] = J(A, B).

[5] proposes a streaming local triangle counting algorithm based on min-wise independent property (Appendix 8.6 outlines the technique).

# Algorithm 2 Binary DN-Graph Mining Variance “BiTriDN”

Require: Graph G(V, E)

1. mk(e) = k(e) = T C(e) + 2, lbk(e) = 2
2. Get support count sc(e) for all edges’ mk λ(e) {This part is the same as in Algorithm 1}
3. for all edge e ∈ G do
4. if(scₘₖ(e) < mk(e) AND lbk(e) < λ(e)) then
5. λ(e) = mk(e) − 1, converge = FALSE
6. else
7. lbk(e) = mk(e)
8. end if
9. mk(e) = λ(e) + lbk(e)
10. end for
11. return λ(e) for each e ∈ E

Algorithm 1. BiTriDN has the advantage of fast convergence if the graph to be mined has many high degree vertices (qualitatively, when |T C(e) + 2 − λ(e)| ≥ logλ(e)). Appendix 8.7 gives the proof of the correctness for both bounding choices. Interested readers are referred to Appendix 8.8 for the complexity analysis of both algorithms.

1For brevity, in following parts of the paper, we use streaming DN-graph mining algorithm instead of explicitly stating “semi-streaming”.

# Algorithm 3 Streaming DN-Graph Mining

# Algorithm “StreamDN”

Require: Graph G(V, E), r : # of scans of graph links k : # of movies records [1].

1) Netﬂix dataset: It is compiled from Netﬂix raw data consisting of 480,000 customers and 17,000 movies records.

2) Flickr dataset: This dataset is derived from the well-known photo sharing network Flickr with 1,715,255 vertices and 22,613,982 edges. Each vertex represents a person.

# 5.1 Performance Evaluation

# 5.1.1 -Graph Mining Accuracy

The first set of experiments evaluate the accuracy of DN-Graph algorithms on the synthetic data generated by GEC. We focused on two algorithms - TriDN and BiTriDN. We compared the results and observed similar behaviors between the two algorithms. Due to space limitation, we only present the results of algorithm BiTriDN.

# 4.2.1 Error-Bound on Streaming -Graph Mining DN

As mentioned in the previous subsections, the number of permutations adopted determines the estimation accuracy of min-wise independent property. The error, however, is bounded. If we denote the joint size as X = |A ∩ B| and the estimated value X = T C(A, B), the error bound is:

P[|X − X| > ϵX] ≥ 2e−ϵ² rJ(A,B) + m|A ∪ B|[5]

The complexity analysis for streaming DN-graph mining is presented in the appendix. In fact, the triangle based approach algorithm can also be applied to dynamic graphs and we attach the adapted algorithm for dynamic setting in Appendix 8.9.

# 5. EXPERIMENTAL STUDY

In this section, we study the performance of the DN-graph mining algorithms. Experimental data come from both theoretically proven data generators ([7]), as well as domain datasets. All the experiments are conducted on a workstation with a Quad-Core AMD Opteron(tm) processor 8356, 128GB RAM and 700GB hard disk. The operating system is Windows server 2003, Enterprize x64 edition.

# Synthetic Graph Generators (GEC)

We use the clique hiding graph generator developed by M. Brockington and J. Culberson [7]. This graph generator randomly embeds a fixed size clique (c) into a graph of (|V |) vertices. The graph density, p, is calculated as p = |V |2|E| / (|V |−1). The resulting graphs are random graphs with one known fixed size clique embedded.

**Table 2: Parameter Table**
|Parameters|Experimental Range|
|---|---|
|c: clique size|[20, 40, 60, 80, 100]|
||V |: # of vertices|[1000,2000, 3000, 4000, 5000]|
|p: edge density(%)|[4, 8, 12, 16, 20]|

# Domain Graph Datasets

We also employ 3 real life datasets in our study. These datasets are either collected by domain experts or extracted from well-known public databases.

1) Protein Protein Interaction (PPI) dataset: This dataset[16] contains 17203 interactions among 4930 proteins.

# 5.1.4 Memory Usage

We also monitor the peak memory usage of both TriDN and BiTriDN on the synthetic data. Figure 10 shows that both algorithms increase their memory usage when the graph size/density increase. Meanwhile, the results tell us that the memory usage of TriDN is always slightly less than that of BiTriDN under the same parameter setting. This is because in BiTriDN, additional memory is used to store both the upper bound and lower bound of the λ value.

|BTv1K|BTv4K|Tv2K|
|---|---|---|
|BTv2K|BTv5K|Tv3K|
|BTp4|BTp12|BTp20|
|BTv3K|Tv1K|BTp8|
|BTp16|Tp4| |

# 5.1.3 Time Performance in Memory

In this study, we evaluate the efficiency (i.e., running time) of the two algorithms TriDN and BiTriDN over the synthetic data generated by GEC. For a fixed parameter setting, the two algorithms converge at different iteration. To remove the effect of different convergence speed towards time performance, all time are measured for only 1 iteration in this study. Both algorithms have almost same behavior for 1 iteration. Figure 8(a) and 8(b) show the running time when |V| is fixed. The results match the complexity analysis in section 4.1. The effects of edges distribution change are shown in figure 8(a) and 8(b). The synthetic graph generator GEC varies the edge distribution by varying the embedded clique size c. Experiments on these data always indicate that only |V| and p affect the running time. Figure 9(a) and 9(b) present the effect of different graph size |E| over the running time. The trend over time roughly follows complexity O(E³).

# 5.1.5 Test on Very Large Graph

In this experiment, we applied BiTriDN on the Flickr dataset. The running time per iteration is between 55 minutes to 1 hour. The stable memory usage is less than 1G. The program converges after 66 iterations. Each iteration’s λ values are recorded for each vertex. When algorithm converges, the largest DN-graph’s highest λ is 278. We note that at the 35th iteration, the largest λ value already reaches 279. Figure 11(a) plots the trend of maximal vertex λ value’s change. From this experiment, the DN-graph mining results have high availability as the results are updated at every iteration. What’s more, if allowing small errors, the program converges very fast. These fast convergence feature is observed for all real datasets we tested on. We did not report all results due to space limitation.

|BiTrH Intermediate Result|StreamH|
|---|---|
|BiTrH Final Result|BiTriH|
|λ|400|
|Max|200|
|% over BiTriH Max|100|

# Figure 11: Performance on Flickr Dataset

# 5.1.6 StreamDN Performance on Flickr Dataset

In this set of experiments, the StreamDN algorithm is ran on the Flickr dataset. The implementation mimics the behavior of disk scan on main memory as our experiment machine has large enough memory. The results in figure 11(b) shows StreamDN over-estimates with respect to BiTriDN algorithm’s results by 72% during the first 66 scans of the whole Flickr dataset. With the analysis of StreamDN’s running time complexity, we confirmed that the triangulation based DN-graph mining algorithms can handle streaming setting with reasonable accuracy.

# 5.1.7 DN-graph Semantics in Various Domain

In the movie co-comments network, two movies are connected by a weighted edge if these two movies share enough commenters such that the Jaccard Coefficient of the two movies’ commenters sets is above a certain threshold. Figure 12 shows a set of movies and their interactions found in 100 movies co-comments network with a threshold of 0.5. These movies are reported with λ = 9. All of the 9 movies have exceptional high IMDB scores (> 8 out of 10, which means they are exceptionally popular). Besides the popularity, we found 7 of them are from USA, while the remaining 2 are from France and Japan respectively. The 9 movies all belongs to genre Violence/Fantasy.

|7 Seconds|The Frogmen| |
|---|---|---|
|They Came Back|ABC|Primetime|
|The Lord of the Rings|Pitcher and the Pin-Up| |
|WWE: Royal Rumble 2005|WWE: Elfen Lied|Armageddon 2003|

Figure 12: Patterns Discovered in NetFlix

|YGL044C|YGR156W|YER133W|YDR301W|YJR093C|YKL018W|
|---|---|---|---|---|---|
|YDR228C|YKL059C|YDR195W|YAL043C|YKR002W|YPR107C|
|YLR115W|YOR250C|YLR277C|YOR179C|YMR061W|YOL123W|
|YNL317W|YNL222W| | | | |

Figure 13: A 20-Protein Complex in Form of DN-Graph

Many proteins are functional only when they are assembled into a protein complex. Our DN-Graph mining algorithm can detect important protein complexes out of large amount of protein-protein interaction (PPI) data. For example, mRNA CF Complex in figure 13 is a 20 protein complex confirmed by the benchmark. The red colored nodes are active proteins that functionally interact with other proteins within the complex. These proteins can be successfully detected as an DN-Graph by our algorithm, while others (blue-colored nodes) are missed out in our results. The reason for missing out those proteins is because these proteins have fewer interactions with the rest of the proteins. Even with those missing points, our results are already a significant improvement over known results (For further results, please refer to Appendix 8.10).

# 6. CONCLUSION

In this paper, we present a new graph dense structure DN-graph. The DN-graph complements popular dense structures by imposing both size and degree constraints. We then discuss the graph local triangulation problem and its connection with DN-graph mining problem. Based on that, we propose solutions to effectively locate DN-graphs. The solutions are set of algorithms catering for different problem settings from in memory to streaming. The iterative, triangulation based solution has the advantages that the details can be abstracted within the triangulation algorithm. Since the algorithm improves the result at every iteration, users can stop the algorithm at any time and get the best results within the time limit. Our experimental study shows our solutions are both time and space efficient.

# 7. REFERENCES

1. Netﬂix Prize Data Set, 2009 (accessed July 23, 2009).
2. J. Abello, M. Resende, and R. Sudarsky. Massive quasi-clique detection. In Proc. 5th Latin American Symposium on Theoretical Informatics, pages 598–612, 2002.
3. I. Akihiro, W. Takashi, and M. Hiroshi. Complete mining of frequent patterns from graphs: Mining graph data. Machine Learning, 50(3):321–354, 2003.
4. P. Aloy, B. B˜aPttcher, H. Ceulemans, C. Leutwein, C. Mellwig, S. Fischer, A. C. Gavin, P. Bork, S. G. Furga, L. Serrano, and R. D. Russell. Structure-based assembly of protein complexes in yeast. Science, 303(5666):2026–2029, 2004.
5. L. Becchetti, P. Boldi, C. Castillo, and A. Gionis. Efﬁcient semi-streaming algorithms for local triangle counting in massive graphs. In ACM KDD ’08, pages 16–24, New York, NY, USA, 2008.
6. V. Boginski, S. Butenko, and P. Pardalos. Mining market data: a network approach. Computer Operational Research, 33(11):3171–3184, 2006.
7. M. Brockington and J. Culberson. Camouﬂaging independent sets in quasi-random graphs. DIMACS Series, 26:75–88, 1994.
8. D. Gibson, R. Kumar, and A. Tomkins. Discovering large dense subgraphs in massive graphs. In VLDB’05, pages 721–732, 2005.
9. J. Han, N. Stefanovic, and K. Koperski. Selective materialization: An efﬁcient method for spatial data cube construction. In PAKDD’98 [Lecture Notes in Artiﬁcial Intelligence, 1394, Springer Verlag, 1998], pages 144–158, 1998.
10. H. Hu, X. Yan, Y. Huang, J. Han, and X. Zhou. Mining coherent dense subgraphs across massive biological networks for functional discovery. Bioinformatics, 21:213–221, 2005.
11. C. F. J. Rivas. Proteincprotein interactions essentials: Key concepts to building and analyzing interactome networks. PLoS Computational Biology, 6:6, 2010.
12. R. Karp. Reducibility among combinatorial problems. The Journal of Symbolic Logic, 40:618–619, 1975.
13. M. Latapy. Practical algorithms for triangle computations in very large (sparse (power-law)) graphs. Journal of Theoretical Computer Science, 407:458–473, 2008.
14. T. Schank and D. Wagner. Finding, counting and listing all triangles in large graphs, an experimental study. In WEA, pages 606–609, 2005.
15. N. Wang, S. Parthasarathy, K. L. Tan, and A. Tung. Csv: visualizing and mining cohesive subgraphs. In SIGMOD’08, pages 445–458, 2008.
16. I. Xenarios and L. S. etc. DIP, the database of interacting proteins: A research tool for studying cellular networks of protein interactions. Nucleic Acids Research, 30(1):303–305, 2002.

# 8. APPENDIX

# 8.2 Proof of Lemma 3.1

First we prove the necessary condition. If a graph contains a DN-graph g with λ = d − 2 and |g| = d, according to the definition of DN-graph, g has d vertices, which shares (d − 2) common neighbors with every connected vertices in g. For any two distinct vertices v and u in g, if they are connected, they both connect to every other vertex inside g. This holds for every vertex pair, which indicates that if g has an edge, it is a clique. While g is a DN-graph, it does not contain a proper super graph which is also a DN-graph, it thus does not have a proper super graph with λ = d − 1 and |g| = d + 1. It does not contain a clique of size d + 1.

The sufficient conditions proof is: if a graph contains a closed clique of size d (*), this clique has d vertices and each pair of vertices share d − 2 common neighbors. λ = d − 2 in this case according to λ definition. Being a closed clique, it does not have a proper super graph which is also a clique. This indicates that it does not have a proper super graph with λ ≥ d − 1 and size = λ + 2. Suppose there is a super graph with λ = d−2+δ and size = d+ϵ, there must be some vertices which are not inside g connecting to at least d − 2 + ϵ − δ d-clique vertices, while d − 2 + ϵ − δ ≤ d, indicating ϵ − δ ≤ 2, which means size ≤ λ. This is either impossible or the super graph is a clique, which contradicts with the assumption (*). So there is not possible such super graph exist. So the d-clique is a DN-graph. This completes the proof.

# 8.3 Proof of Theorem 3.1

To prove the correctness of theorem 3.1, we use the abstract graph in figure 15. The complete proof consists of two steps. Firstly, G′ must exist. Secondly, G′ must contain some max-min DN graph. To prove the existence of G′, we construct G′ using graph vertices/edges and their λ values. First pick a vertex v with λ(v) ≥ λ(u) for all (u ∈ N (v)). Denote λ(v) as λₘₐₓ. By the definition of local λ value, λ(v) participates in a connected graph G′ with λ(G′) = λₘₐₓ. From v, we find all its immediately connected neighbors that have λ(u) = λₘₐₓ. From each u, we find u’s immediately connected neighbors with local λ value λₘₐₓ. This process propagates until no such neighbor exists. The collection of discovered vertices form a connected subgraph G′ with λ value λₘₐₓ.

Next, we show that G′ contains a DN-graph. By the first part of the proof, G′ contains all vertices and edges with λ value λₘₐₓ. For a vertex v ∈ G′, it only can form DN-graph of λ = λₘₐₓ with vertices inside G′. If denoting the minimal set of vertices from G′ that form a DN-graph with v′ as Vmin, the subgraph Vmin ∪ v′ is also a DN-graph. This proves that a graph G′ containing the set of vertices with λ(v) = λₘₐₓ > λ(u) where u ∈ N(G′) must participate in a DN-graph. The condition that λ(v) = λₘₐₓ and λ(u) = λ(v) must hold.

Figure 15: Proof of Theorem 3.1

Figure 14: Comparison between Different Dense Sub-structures

# Algorithm 5 Streaming Triangulation Algorithm

Require: Graph G(V, E), r : # of scans of graph links, k : # of bits for hash values

1. mk(e) = k(e) = T C(e) + 2, lbk(e) = 2
2. Y = 0, min(V ) = 0
3. for s = 1 TO r do
4. Hash every vertex label hₛ(v) to any random k bits
5. for all vertex v ∈ V and its neighbor u do
6. min(v) = min( min(v),hₛ(u) )
7. end for
8. for all vertex v ∈ V and its neighbor u do
9. if (min(u)==min(v)) then
10. Increment Y (u, v)by 1
11. end if
12. end for
13. end for
14. for all every vertex v in G do
15. T C(v) = ∑u∈N(v) YY (v,u) (|N(v)| + |N(u)|)
16. end for
17. return All triangles in G

# 8.4 Closed Clique Finding is NP-Complete

A closed clique is the local maximal clique, where no proper super graph of it is also a clique. The problem of detecting cliques is a well known NP-complete problem, which is first discussed in the landmark paper [12]. As a clique possessing certain property (here, local maximality), a closed clique detection problem is also an NP problem.

# 8.5 Graph Triangulation Algorithms

The exact graph triangulation algorithm was first proposed in [13].

# Algorithm 4 Local Triangulation Algorithm

Require: Graph G(V, E)

1. mk(e) = k(e) = T C(e) + 2, lbk(e) = 2
2. Order vertices and edges according to degrees
3. for all dense vertex v ∈ G do
4. Retrieve all v’s dense neighbors u
5. Joint v and u’s neighborhoods to find triangle &lt; v, u, w &gt;
6. end for
7. for all sparse vertex e(v, u) ∈ G do
8. Join v and u’s neighbor lists to find triangles containing edge triangle &lt; v, u, w &gt;
9. end for
10. return All triangles in G

# 8.7 Correctness of λ Bounding

Let us denote the actual λ value for an edge as λ(e), and the exact supporting neighbor count as sc. The upper bound of λ value is denoted as k(e) and the supporting neighbor count of k(e) is denoted as scₖ(e). To prove the correctness of Algorithm 1, we need to show that 1) k(e) is always an upper bound of λ(e). 2) k(e) converges.

PROOF. 1) For the first bounding choice, At the beginning of the algorithm 1, k(e) is equal to triangle count for e, T C(e). since k(e) ≥ λ(e). If the algorithm stops, the upper bound invariance holds. Suppose the invariance holds for iteration i > 0, k(e) ≥ λ(e), at iteration i+1, k(e) is updated to k(e)−1 when this condition holds: the number of neighbors having λ values greater or equal to k(e) is less than k(e). This condition uses the value of k from the neighborhood vertices to verify whether the current iteration’s k(e) value is valid. Since the neighbor’s k values are the upper bounds of their actual λ values, the number of qualified candidates sc(e) ≥ scₖ(e). Thus when scₖ(e) is less than k(e), k(e) is definitely greater than the real λ(e) value (as in 4.1). In that case, k(e) is reduced by 1. And the new k(e) value is still an upper bound. The upper bounds invariance is proven to hold. 2) For the second bounding choice (as in algorithm 2), the proof of upper bound invariance follows with the exceptions that this bounding choices test on the median of possible λ range instead of k(e) − 1.

The convergence of k(e) is due to the monotonic decreasing of k(e). The algorithm initializes k(e) as triangle counts. This is an upper bound of λ(e). After that, algorithm only decreases k(e). As λₐ(e) is always an upper bounds of the actual value λ(e), λₐ(e) value will converge.

# 8.8 Complexity Analysis

The triangulation algorithm (in Appendix 8.5) sorts vertices and adjacency list into descending order of degrees. The operations require O(|V |log|V |) time complexity. After that, it counts triangles within the graphs for each vertex. To count triangles, the algorithm separates vertices into dense vertices and sparse ones according to vertices’ degrees. For dense vertex, the algorithm lists the number of triangles |V | participating in O(|E|) time. The total complexity for counting dense vertices is O(|V ||E|). For sparse vertices, the algorithm counts sparse edges that intersects with sparse vertices.

For a sparse vertex/edge, its neighborhood size is at most constant 8.10 More Semantic Findings (say S). The counting over sparse edges requires O(S|E|) time. If setting S = √|E|, taking into consideration of the complexity of counting on dense vertices, The time complexity for triangle counting procedure is O(|E|³).

TriDN in Algorithm 1 iterates on all triangles that form the graph. Each iteration also requires O(|E|³) time. For a fixed number of iteration k, the algorithm needs O(k|E|³) time in total. If insisting on convergence, the algorithm may need up to O(k|V ||E|³). As we may need to test local λ value λ(e) from v − 2 down to 3. The iterative version of the algorithm for λ mining reduces time complexity to O(klog|V ||E|³) since it employs the binary search paradigm to test possible λ(e) for every e. The space complexity of both DN graph mining algorithms are similar. The triangulation stage requires O(|V|log|V| + |E|) while the iteration process requires O(|E|).

For streaming DN graph mining, Algorithm 3 first performs semi-streaming triangulation following the idea proposed in [5]. While the semi-streaming triangulation scans the graph r passes to apply min-wise independent set principle and an additional pass to calculate the estimator of triangle counts, its complexity is of O(r|E|). The remaining steps of streaming DN graph mining requires O(|E|) time for every iteration. For a fixed number of iteration w, the algorithm needs O(w|E|) time. In summary, the time complexity of streaming DN graph mining is of O(k|E|), where k is a constant.

# 8.9 Dynamic DN-Graph Mining

We have discussed solutions for finding handling static graphs. These solutions can be extended to graphs with dynamic topology with minimal modification. Recall that the triangulation based DN-graph mining solution consists of two stages. In the first stage, algorithm in figure 1 performs local triangulation on the whole graph. The next step is to iterate on each discovered triangle. For each triangle, the algorithm uses it to verify whether it can support its edges’ λₐ(e) value. After scanning all triangle once, the λₐ(e) values for each edge are updated accordingly.

A dynamic graph G(V,E) = {G(V, E)} changes its topology over time. Such dynamics can also be modelled as the emerging and disappearing of triangles inside G. At each discrete time t, the instance of a streamed graph is the set of vertices and edges represented at t, we use Gᵗ(V t, Et) to represent it. Without loss of generality, this chapter only concerns the addition of edges. When a new edge e appears between vertex a and b, this edge’s initial λₐ(e) is set to be the size of N(a) ∩ N(b), while edge λₐ(a, n) and λₐ(b, n) increase by 1 if they share neighbor vertex n before new edge comes. After the process of adjusting λₐ(e) values for dynamically affected edges, we then iterate on the new set of triangles following the same way as in algorithm in Figure 1.

# 8.9.1 Complexity of Dynamic DN-Graph Mining

Denoting the total number of edges of a dynamic graph G as |E∗|. Followed previous discussion, we only process each edge once when it first appears or its neighborhood information changes. If the graph is a sparse graph, the neighborhood size of any vertex is a constant. Thus in sparse graph, the complexity for dynamic DN-graph mining is of O(k|E∗|) where k is the number of iterations. The space complexity is O(E∗) as we need to store DN information for each edge appeared.

Note that certain protein (such as YMR268C) could not be detected due to low connectivity with other members in the complex. With the observation of high connectivity among the rest of the proteins, we strongly urge biologists to experimentally search for the “missing“ connections between missed proteins and the rest of the protein members. (For clarity, matches are marked red; missing proteins are marked as blue points. Proteins that are not present in known benchmark pattern but discovered as members of an DN-Graph are marked as yellow.)

