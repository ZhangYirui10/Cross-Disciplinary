See discussions, stats, and author profiles for this publication at: https://www.researchgate.net/publication/3297636

# Continuous Skyline Queries for Moving Objects

Article in IEEE Transactions on Knowledge and Data Engineering · January 2007

DOI: 10.1109/TKDE.2006.185 · Source: IEEE Xplore

|CITATIONS|READS|
|---|---|
|143|238|

4 authors, including:

- Zhiyong Huang - National University of Singapore
- Hua Lu - poly-mtl
- Anthony Tung - National University of Singapore

|83 PUBLICATIONS|1,306 CITATIONS|
|---|---|
|127 PUBLICATIONS|3,753 CITATIONS|
|215 PUBLICATIONS|9,005 CITATIONS|

All content following this page was uploaded by Zhiyong Huang on 16 December 2013.

The user has requested enhancement of the downloaded file.

# Continuous Skyline Queries for Moving Objects

# Zhiyong Huang, Hua Lu, Beng Chin Ooi, Anthony K.H. Tung

# School of Computing, National University of Singapore

{huangzy, luhua, ooibc, atung}@comp.nus.edu.sg

# Abstract

The literature on skyline algorithms has so far dealt mainly with queries of static query points over static datasets. With the increasing number of mobile service applications and users, however, the need for continuous skyline query processing has become more pressing. A continuous skyline query involves not only static dimensions but also the dynamic one. In this paper, we examine the spatiotemporal coherence of the problem and propose a continuous skyline query processing strategy for moving query points. First, we distinguish the data points that are permanently in the skyline and use them to derive a search bound. Second, we investigate the connection between the spatial positions of data points and their dominance relationship, which provides an indication of where to find changes in the skyline and how to maintain the skyline continuously. Based on the analysis, we propose a kinetic-based data structure and an efficient skyline query processing algorithm. We concisely analyze the space and time costs of the proposed method and conduct an extensive experiment to evaluate the method. To the best of our knowledge, this is the first work on continuous skyline query processing.

# Keywords

Skyline, continuous query processing, moving object databases.

# Regular submission to IEEE TKDE

(submitted in July 2005, first revised in December 2005, revised again in July 2006)

# Original log number

TKDE-0272-0705

# Contact Author

Hua Lu

School of Computing

National University of Singapore

3 Science Drive 2, Singapore 117543

Phone: (65)-6874-4774

# 1 Introduction

With rapid advances in electronics miniaturization, wireless communication and positioning technologies, the acquisition and transmission of spatiotemporal data using mobile devices are becoming pervasive. This fuels the demand for location-based services (LBS) [23, 4, 29, 28]. A skyline query retrieves from a given dataset a subset of interesting points that are not dominated by any other points [6]. Skyline queries are an important operator of LBS. For example, mobile users could be interested in restaurants that are near, reasonable in pricing, and provide good food, service and view. Skyline query results are based on the current location of the user, which changes continuously as the user moves.

The existing work on skyline queries assumes a static setting, where the distances from the query point to the data points do not change. Using the common example in the literature shown in Figure 1, assume there is a set of hotels, and for each hotel, we have its distance to the beach (x axis) and its price (y axis). The interesting hotels are all the points not worse than any other point in both the distance to the beach and the price. Hotels 2, 4 and 6 are interesting and can be derived by a skyline query, for their distances to the beach and their prices are preferable to those of any other hotels. Note that a point with minimum value in any dimension is a skyline point – hotels 2 and 6 for example. Also, skyline is different from convex hull in that it is not necessarily convex. In this example, hotel 4 makes the skyline not convex.

In the above query, the skyline is obtained with respect to a static query point; in this case, it is the origin of both axes. Now, let us change the example to the scenario of a tourist walking about to choose a restaurant for dinner. We consider three factors in the skyline operation, namely the distance to the

restaurant, the average price of the food and the restaurant rank. Different from the previous example, the distance now is not fixed since the tourist is a moving object. Figure 2 shows the changes in the skyline due to the movement. In the figure, the positions of the restaurants are drawn in the X-Y plane while the table shows their prices and ranks. Lower values are preferred for all three dimensions. A tourist as the query point moves as the arrow indicates from time t₁ to t₂. The skyline – which refers to the interesting restaurants – changes with respect to the tourist’s position. Skylines at different times are indicated by different line chains. The situation becomes more complex when all data points can move, which is frequent in real-time applications like e-games and digital war systems. For instance, one player in a field fighting game wants to keep track of those enemies who are close and most dangerous in terms of multiple aspects like energy, weapon, strategy and etc.

|y|Restaurant Price|Rank|
|---|---|---|
|1|6|4|
|2|5|.|
|3|8|4|
|4|4|1|
|5|1|2|
|6|2|4|

Figure 2. Skylines in mobile environment

In this paper, we address the problem of continuous skyline query processing, where the skyline query point is a moving object and the skyline changes continuously due to the query point’s movement. We solve the problem by exploiting its spatiotemporal coherence. Coherence refers to properties that change in a relevant way from one part to other parts within a scene in computer graphics [8], which is used to build efficient incremental processing for operations such as area filling and face detection. We use spatiotemporal coherence to refer to those spatial properties that do not change abruptly between continuous temporal scenes. The positions and velocities of moving points do not change by leaps between continuous temporal scenes, which enables us to maintain the changing skyline incrementally. First, we distinguish the data points that are permanently in the skyline and use them to derive a search bound to constrain the processing of the continuous skyline query. Second, we investigate the connection be-

tween the spatial locations of data points and their dominance relationship, which provides an indication of where to find changes in the skyline and update it. Third, to efficiently support the processing of continuous skyline queries, we propose a kinetic-based data structure and the associated efficient query processing algorithm. We present concise space and time cost analysis of the proposed method. We also report on an extensive experimental study, which includes a comparison of our proposed method with an existing method adapted for the application. The results show that our proposed method is efficient in terms of storage space, and is especially suited for continuous skyline queries. To the best of our knowledge, this is the first work on continuous skyline queries in the mobile environment.

The rest of this paper is organized as follows. In Section 2, we present the preliminaries including our problem statement and a brief review of related work. In Section 3, we present a detailed analysis of the problem. In Section 4, we propose our solution which continuously maintains the skyline for moving query points through efficient update. The experimental results are presented in Section 5. Section 6 concludes the paper.

# 2 Preliminaries

# 2.1 Problem Statement

In LBS, most queries are continuous queries [28]. Unlike snapshot queries that are evaluated only once, continuous queries require continuous evaluation as the query results vary with the change of location and time. Continuous skyline query processing has to re-compute the skyline when the query location and objects move. Due to the spatiotemporal coherence of the movement, the skyline changes in a smooth manner. Notwithstanding this, updating the skyline of the previous moment is more efficient than conducting a snapshot query at each moment.

For intuitive illustration, we limit the data and the moving query points to a two-dimensional (2D) space. Our statement is however sufficiently general for high-dimensional space too. We have a set of n data points in the format &lt;xi, yi, vxi, vyi, pi1, ..., pij , ..., pim&gt; (i = 1, ..., n), where xi and yi are positional coordinate values in the space, vxi and vyi are respectively velocity in the X and Y dimensions.

while pij’s (j = 1, ..., m) are static non-spatial attributes, which will not change with time. For a moving object, xi and yi are updated using vxi and vyi. When it is stationary, vxi and vyi are zero. We use T uple(i) to represent the i-th data tuple in the database. Users move in the 2D plane. Each of them moves in velocity (vqx, vqy), starting from position (xq, yq). They pose continuous skyline queries while moving, and the queries involve both distance and all other static dimensions. Such queries are dynamic due to the change in spatial variables. In our solution, we only compute the skyline for (xq, yq) at the start time 0. Subsequently, continuously query processing is conducted for each user by updating the skyline instead of computing a new one from scratch each time. Moving points are allowed to change their velocities, which will be addressed in Section 4.2.1. Without loss of generality, we restrict our discussion to what follows the MIN skyline annotation [6], in which smaller values of distance or attribute pij are preferred in comparison to determine dominance between two points.

# 2.2 Time Parameterized Distance Function

In our problem, the distance between a moving query point and a data point is involved in the skyline operator. For a moving data point pti starting from (xi, yi) with velocity (vix, viy), and a query point starting from (xq, yq) moving with (vqx, vqy), the Euclidean distance between them can be expressed as a function of time t: dist(q(t), pti(t)) = √at² + bt + c, where a, b and c are constants determined by their starting positions and velocities: a = (vix − vqx)² + (viy − vqy)²; b = 2[(xi − xq)(vix − vqx) + (yi − yq)(viy − vqy)]; c = (xi − xq)² + (yi − yq)². For simplicity, we use function fi(t) = at² + bt + c to denote the square of the distance. When pti is static, a, b and c are still determined by the formulas above with vix = viy = 0. This time parameterized distance function has been used in literature to help processing queries in moving object databases [27, 10, 21].

# 2.3 Terminologies

For two points pt₁ and pt₂, if dist(pt₁, q) ≤ dist(pt₂, q) and pt₁.pₖ ≤ pt₂.pₖ, ∀k, and at least one < holds, i.e., ∃k, such that pt₁.pₖ < pt₂.pₖ, we say pt₁ dominates pt₂. We say pt₁ and pt₂ are incomparable if pt₁ does not dominate pt₂, and pt₁ is not dominated by pt₂. We use pt₁ ≺ pt₂ to represent that pt₁

dominates pt₂, and pt₁ π pt₂ to represent that pt₁ dominates pt₂ for all static non-spatial dimensions. In kinetic data structures, a certiﬁcate is a conjunction of algebraic conditions, which guarantees the correctness of some relationship to be maintained between mobile data objects. Readers are referred to [3] for the formal and detailed description of kinetic data structures (KDS). In this paper, we use a certiﬁcate to ensure the status of a data point is valid within a period of time t. For example, a certiﬁcate of a point can guarantee it staying in the skyline for a period of time t. Beyond t, its certiﬁcate is invalid and an event will trigger a process to update the certiﬁcate, which may result in a change in the skyline.

# 2.4 Related Work

One area with related work concerns skyline queries. Inspired by work on contour problem [15], maximum vectors [14], convex hull [20] and multi-objective optimization [25], Borzonyi, Kossmann and Stocker [6] introduced the skyline operator into relational database context and proposed two processing algorithms: Block Nested Loop (BNL) and Divide-and-Conquer (D&C). D&C approach partitions the dataset into several parts, processes each part in memory and ﬁnally merges all partial skylines together. BNL scans the dataset sequentially and compares each new point to all skyline candidates kept in memory. Chomicki, Godfrey, Gryz and Liang [7] proposed a variant of BNL by pre-sorting the dataset according to some monotone scoring function. Tan, Eng and Ooi [26] proposed two progressive processing algorithms. In Bitmap approach, each data point is encoded in a bit string and skyline is computed by some efﬁcient operations on bit matrix of all data points. In Index approach, data points are transformed into a single dimensional space and then indexed by B⁺-tree which facilitates skyline computation. Kossmann, Ramsak and Rost [13] proposed another progressive processing algorithm Nearest Neighbor (NN) based on the depth-ﬁrst nearest neighbor search [22] via R∗-tree. Papadias and Tao [18, 19] proposed an improved algorithm named Branch-and-Bound Skyline (BBS) based on the best-ﬁrst nearest neighbor search [9]. By accessing only nodes that contain skyline points, BBS incurs optimal node access and so far is the most efﬁcient skyline algorithm in static settings. In a slightly different context, Balke, Guntzer and Zheng [2] addressed skyline operation over web databases where different dimensions are stored in different data sites.

Another area with related work is that of kinetic data structures (KDS). Basch, Guibas and Hershberger [3] proposed a conceptual framework for KDS as a means to maintain continuously evolving attributes of mobile data. KDS keeps the relationship of interest between data in some specific structures, and the contents do not change unless the relationship has changed. In this way, data retrieval results based on the relationship of interest can be maintained when the data points move continuously. KDS and its underlying ideas have inspired some unique query processing techniques for moving objects database (MOD). Mokhtar, Su and Ibarra [16] proposed an event-driven approach to maintain the results of k-NN queries on moving objects while time elapses. All moving objects are sorted by their distance to the query point, while events are computed and stored to indicate when and how the order will change. To reduce the points sorted in the KDS, Iwerks, Samet and Smith [10] proposed the Continuous Windowing (CW) k-NN algorithm, which limits search to a smaller region and accesses other points only as needed.

# 3 The Change of Skyline in Moving Context

In this section, we analyze the change in skyline in continuous query processing. We first point out the search bound that can be used to filter out unqualified data points in determining the skyline for a moving query point. Then we carry out an analysis of the skyline change due to the movement, which reveals some insights for the algorithms in the next section.

# 3.1 Search Bound

Although in our problem the skyline operator involves both dynamic and static dimensions, some data points could be always in the skyline no matter how the data points and query points move. This is because they have dominating static non-spatial values, which guarantee that no other objects can dominate them. We denote this subset of skyline points as SKₙₛ and the whole set of skyline points as SKₐₗₗ. We call SKₙₛ the static partial skyline, and SKₐₗₗ the complete skyline.

We call points in SKₙₛ permanent skyline points. In this way, we distinguish those points always in the complete skyline from the rest of the dataset. The benefit of this discrimination is threefold:

(1) It extracts the unchanging part of a continuous skyline query result from the complete skyline SKall. This allows efforts in query processing to be concentrated on the changing part only, i.e., SKall−SKns. We name that part SKchg, and call those points in it volatile skyline points. In continuous skyline query processing, only SKchg needs tracking for each query. In this manner, we can reduce overall processing cost.

(2) The discrimination can reduce the amount of data to be sent to clients. Since SKns is always in the final skyline result, we need to send it only once from server to client. This benefits mobile applications where clients and servers are usually connected via limited bandwidth.

(3) Static partial skyline SKns also provides an indication of the search bound for processing a continuous skyline query. Since SKns is always contained in SKall, for any point not in SKns to enter SKall, it must be incomparable to any item in SKns. More specifically, it must have advantage in distance to the query point since it is dominated in all static dimensions by at least one point in SKns. This leads to Lemma 3.1.1.

# Lemma 3.1.1

At any time t, if spf is the farthest point in SKns to the query point, then any point pt not nearer to the query point than spf is not in the complete skyline.

Proof. Obviously pt &not;∈ SKns, thus ∃sp ∈ SKns such that ∀k, sp.pk ≤ pt.pk and at least one inequality holds. From dist(q, sp) ≤ dist(q, spf) and dist(q, spf) ≤ dist(q, pt), we get dist(q, sp) ≤ dist(q, pt) by transitivity. Because of its disadvantage in both spatial and non-spatial dimensions, pt is dominated by sp at time t so that it is not in the complete skyline. ¶

Lemma 3.1.1 indicates a search bound for the complete skyline. This can be used to filter out unqualified points in query processing: those farther away than all points in SKns cannot be in the complete skyline. Refer to the example in Figure 2, SKns = {3, 5}. At time t1, SKchg = {1} and restaurants 2, 4 and 6 are not in the skyline as they are farther to the query point than restaurant 5, which is the farthest permanent skyline point to the query point.

# 3.2 Change in the Skyline

When the query point q and data points move, their distance relationships may change. This causes the skyline to change as well. As discussed in Section 3.1, such changes only happen to SKchg, i.e. SKall − SKns. It is also mentioned in Section 2.2 that the square of the distance from each point to the query point can be described as a function of time t. Figure 3 illustrates an example of such functions of several points with respect to the moving query point.

|pt di2|5|distance|
|---|---|---|
|pt 4| | |
|pt 3| | |
|pt 2| | |
|pt 1|&lt; pt 1, pt 2, tx &gt;| |
|0|tx|time|

Figure 3. An example of distance function curves

Intuitively, a skyline point si in SKchg before time tx may leave the skyline after tx. On the other hand, a non-skyline point nsp at time tx may enter the skyline and become part of SKchg after tx. For the former, after time tx, si must be dominated by a skyline point sj in SKall. For the latter, when nsp enters the skyline after time tx, those points that used to dominate nsp before tx will stop dominating it. That moment tx is indicated by an intersection of two distance function curves. We use &lt;pt₁, pt₂, tx&gt; to represent an intersection shown in Figure 3, where at time tx point pt₂ is getting closer to the query than point pt₁, opposite to the situation before tx. From the figure, we can see that such an intersection only alters pt₁ and pt₂’s presence in or absence from SKchg if it does cause change. This is because before and after the intersection, the only change of comparison is dist(q, pt₁) &lt; dist(q, pt₂) to dist(q, pt₂) &lt; dist(q, pt₁). If no intersections happen, the skyline does not change at all because the inequality relationship between the distances of all points to the query point remains unchanged.

Nevertheless, not every intersection necessarily causes the skyline to change. Whether an intersection &lt;pt₁, pt₂, tx&gt; causes change is relevant to which set pt₁ and pt₂ belong to just before time tx, i.e., SKns, SKchg or SKall (neither of the former two, i.e., not in SKall).

9

clearly describe these possibilities.

# Lemma 3.2.1

An intersection &lt;pt₁, pt₂, tₓ&gt; (dist(q, pt₁) &lt; dist(q, pt₂) before tₓ) has no influence on the skyline if one of the following conditions holds before tₓ:

1. pt₁ ∈ SKₙₛ and pt₂ ∈ SKₙₛ
2. pt₁ ∈ SKₙₛ and pt₂ ∈ SKchg
3. pt₁ ∈ SKₐₗₗ and pt₂ ∈ SKₙₛ
4. pt₁ ∈ SKₐₗₗ and pt₂ ∈ SKchg
5. pt₁ ∈ SKₐₗₗ and pt₂ ∈ SKₐₗₗ

Proof. (1) This is obvious according to the definition of permanent skyline points.

(2) Obviously pt₁ does not leave the skyline. Assuming that pt₂ leaves the skyline after tₓ, there must be another skyline point s dominating it, i.e., dist(q, s) &lt; dist(q, pt₂) for t &gt; tₓ and ∀k, s.pₖ ≤ pt₂.pₖ. Since intersection &lt;pt₁, pt₂, tₓ&gt; does not change the distance inequality relationship between s and pt₂, dist(q, s) &lt; dist(q, pt₂) also holds for t &lt; tₓ. Thus s dominates pt₂ before tₓ, which contradicts pt₂ ∈ SKchg before tₓ. Therefore pt₂ does not leave the skyline either, and there is no influence on the skyline.

(3) Since pt₁ ∈ SKₐₗₗ before tₓ, there must be at least one skyline point s ∈ SKₐₗₗ dominating it. Because dist(q, s) &lt; dist(q, pt₁) does not change after the intersection, s still dominates pt₁ and thus pt₁ will not enter the skyline. Since pt₂ is a permanent skyline point, it will not leave the skyline.

(4) Due to the same reasoning as in (3), pt₁ will not enter the skyline after tₓ. Due to the same reasoning in (2), pt₂ itself will not leave the skyline after tₓ.

(5) Due to the same reasoning as in (3), neither pt₁ nor pt₂ will enter the skyline after tₓ.

# Lemma 3.2.2

An intersection &lt;pt₁, pt₂, tₓ&gt; (dist(q, pt₁) &lt; dist(q, pt₂) before tₓ) may have influence on the skyline if one of the following conditions holds before tₓ:

1. pt₁ ∈ SKₙₛ and pt₂ ∈ SKₐₗₗ
2. pt₁ ∈ SKchg and pt₂ ∈ SKₙₛ

# Table 1. Intersections and possible skyline changes

|pt1 \ pt2|SKns|SKchg|SKall|
|---|---|---|---|
|SKns|—|—|√|
|SKchg|√|√|√|
|SKall|—|—|—|

(3) pt₁ ∈ SKchg and pt₂ ∈ SKchg

(4) pt₁ ∈ SKchg and pt₂ ∈ SKₐₗₗ

Proof. (1) Obviously pt1 will not leave the skyline after tx. Since pt1 ∈ SKₐₗₗ before tx there must be at least one skyline point in SKₐₗₗ dominating it. If pt1 is the only dominating pt2 before tx, after tx, pt1 will stop dominating pt2 and no other skyline points will dominate it. Consequently, pt2 will enter the skyline after tx.

(2) Obviously pt2 will not leave the skyline after tx. But if ∀k, pt2.pk ≤ pt1.pk holds, pt2 will dominate pt1 and cause pt1 to leave the skyline since dist(q, pt2) < dist(q, pt1) holds after tx.

(3) If ∀k, pt2.pk ≤ pt1.pk holds, pt2 will dominate pt1 and cause pt1 to leave the skyline because dist(q, pt2) < dist(q, pt1) holds after tx. Due to the same reasoning as in (2) of Lemma 3.2.1, pt2 itself will not leave the skyline since no other points will dominate it after tx.

(4) Due to the same reasoning as in (1), pt2 may enter the skyline after tx.

Table 1 lists all possibilities attached to an intersection. For (4) in Lemma 3.2.2, an interesting issue is whether pt2 can dominate pt1 after time tx.

# Lemma 3.2.3

For an intersection &lt;pt1, pt2, tx&gt; (dist(q, pt1) < dist(q, pt2) before tx) in which pt1 ∈ SKchg and pt2 ∈ SKₐₗₗ before tx, pt1 will not be dominated by pt2 and leave the skyline after tx, if no other intersection happens at the same time and the static non-spatial values of pt1 and pt2 are not the same for all dimensions.

Proof. Assume that pt1 will be dominated by pt2 and leave the skyline after tx, we have pt2 π pt1. Because pt2 is not in SKₐₗₗ before tx, in SKₐₗₗ there must exist at least one pt3 dominating pt2, i.e. pt3 ≺ pt2. For simplicity of presentation, we assume that pt3 is the only one skyline point of such kind. By transitivity, we have pt3 π pt1. But because pt1 is in SKchg, the distance from pt3 to the query

point must be larger than that from pt₁ before tₓ; otherwise pt₃ ≺ pt₁ means pt₁’s absence from SKchg. Thus for pt₂ to dominate pt₁ after tₓ, it must first become incomparable to pt₃, which requires that an intersection between pt₁ and pt₃ must happen no later than tₓ. If the time of intersection is earlier than tₓ, however, pt₂ will be in SKchg before tₓ. Thus that time must only be tₓ. Therefore, their three distance function curves must intersect at the same point, and &lt;pt₁, pt₂, tₓ&gt; is not the only intersection at time tₓ.

Note that pt₃ cannot be pt₁ in the above proof. Otherwise, before tₓ, we have pt₁ ≺ pt₂. Thus, ∃k such that pt₁.pₖ &lt; pt₂.pₖ because their static non-spatial attribute values are not the same for all dimensions. This means pt₂ cannot dominate pt₁ even after time tₓ.

d i 2

d i s t a n c e

p t 2

p t 3 p t 2 in S K c h g !

p t &lt; p t 1 , p t 2 , t x &gt;

1 &lt; p t 1 , p t 3 , t x &gt;

&lt; p t 3 , p t 2 , t x &gt;

0 t x - D t t x t i m e

Figure 4. An example of multiplex intersection

Figure 4 shows such a scenario indicated by Lemma 3.2.3, and we call such an intersection multiplex intersection. One feasible processing strategy for this situation is to only consider if pt₂ has the chance to enter SKchg. We need to check if pt₁ is the only one that used to dominate pt₂. We ignore the possibility that pt₂ might enter the skyline and start dominating pt₁ at the same time. That possibility is indicated by other intersections at the same time, each of which is to be processed in isolation.

Accordingly, the intersection &lt;pt₁, pt₂, tₓ&gt; in Figure 4 will be ignored. After time tₓ, both pt₂ and pt₃ are in SKₐₗₗ but pt₁ is not. This result can be achieved as long as the three intersections are correctly processed one by one according to our discussion above, regardless of the order in which they are processed. Now, let us look at the processing of the intersections in the order listed in the figure. First, &lt;pt₁, pt₂, tₓ&gt; does not change the skyline because pt₁ does not dominate pt₂ and thus pt₂ will not enter SKchg though it is getting closer to the query point than pt₁. Second, &lt;pt₁, pt₃, tₓ&gt; will

cause pt₁ to leave SKchg because pt₁ starts dominating it. Finally, &lt;pt₃, pt₂, tₓ&gt; will cause pt₂ to enter SKchg because pt₃ is the only one that used to dominate pt₂ and now it stops dominating the point as its distance to the query point becomes larger. The procedures of other processing orders are similar and thus omitted due to space constraint.

An extreme situation is that many distance function curves are involved in the same multiplex intersection. Our processing strategy can also ensure the correct change as long as each legal intersection is processed correctly in isolation. In fact, this situation is rather special and seldom happens because it requires that all the points involved to be on the same circle centered at the query point. This situation usually happens to minority data points only, and it becomes more infrequent in the moving context.

# To summarize the above analysis, we only need to take into account two primitive cases in which the skyline may change.

# Case 1

Just before time tₓ, si ∈ SKchg and ∃sj ∈ SKₐₗₗ s.t. sj π si. At time tₓ, an intersection &lt;sᵢ, sⱼ, tₓ&gt; between their distance function curves happens. Then from time tₓ on, sⱼ ∈ SKchg and leaves the skyline because sj ≺ si, and sj ∈ SKₐₗₗ still.

# Case 2

Just before time tₓ, nsp ∉ SKₐₗₗ and ∃si ∈ SKₐₗₗ s.t. si ≺ nsp. At time tₓ, an intersection &lt;si, nsp, tₓ&gt; between their distance function curves happens. Then from time tₓ on, nsp ∈ SKchg because ∃sj ∈ SKₐₗₗ s.t. sj ≺ nsp.

Case 1 determines a skyline change, whereas Case 2 suggests a possibility of change which requires further checking. For a period of time before the change in Case 1, sj must be out of the circle determined by the query point q and si. We use Cir(q, si) to denote the circle whose center is q and radius is dist(q, si). In Case 2, the possible non-skyline point nsp is also out of circle Cir(q, si) for a period of time before the change. Namely, the distance from each current skyline point (permanent or volatile) provides indication of future change in the skyline.

13

# 3.3 Continuous Skyline Query Processing

We now address the issues of continuous skyline query processing. A naive way is to pre-compute and store all possible intersections of any pair of distance function curves, and then process each one when its time comes according to the discussion in Section 3.2. This method produces many false hits which actually do not cause skyline to change as we have shown in Table 1.

Based on those observations, we compute and store intersections in an evolving way. We only keep those intersections with possibility to change the skyline according to Table 1. Specifically, first, we get the initial skyline and compute some intersections of the distance curves in terms of the current skyline points. Then, when some intersections happen and the skyline is changed, we further compute intersections in terms of the updated skyline. By looking into the near future, we ensure that the skyline query result is kept updated, and more information will be obtained later for updating the skyline further into the future.

Besides, we keep all the current skyline points sorted based on their distance to the query point. At each evolving step, we only compute those possible intersections that involve points between two adjacent skyline points si and si+1, and will happen before si and si+1 stop being adjacent. Therefore, we need to keep track of any intersection between two skyline points that are adjacent to each other in sorted order.

|di|2|
|---|---|
|r6| |
|r4| |
|r5| |
|r2| |
|r3| |
|r1| |

Figure 5 shows the distance curves of the restaurant example in Figure 2. At time t1, restaurants r1, r3 and r5 are three adjacent skyline points, and only those two dotted intersections are computed and stored for future processing. Then at time t1,3, r1 will leave the skyline as r3 becomes to dominate it.

time t5,4, r4 will enter the skyline as its only dominator r5 stops dominating it. Not all intersections are stored for processing, e.g., the intersection between r2 and r4, and that between r4 and r1.

Note our method is a kind of sweeping algorithm but with two distinctive features. We have a search bound which renders the search limited in some specific regions instead of the whole data space. The case study in Section 3.2 helps identify result changes and reduce processing in the maintenance. The next section addresses the data structure and relevant algorithms in detail.

# 4 Data Structure and Algorithms

# 4.1 Data Structure

We use a bidirectional linked list, named Lsp to store all current skyline points, which are sorted in ascending order of their distances to the query point. For each current skyline point si, we keep an entry of form (flag, tuple id, a, b, c, tv, tskip). flag is a boolean variable indicating if si is in SKns. tuple id is the tuple identifier of si which can be used to access the record. a, b, c are coefficients of the distance function between si and query point q, introduced in Section 2.2. tv is only available to each changing skyline point, indicating its validity time. tskip is the time when si will exchange its position with its successor in Lsp. Besides Lsp, a global priority queue Qe is used to hold all events derived from certificates to represent future skyline changes, with preference being given to earlier events.

Based on the analysis in Section 3, we define three kinds of certificates used in the KDS, which are listed in Table 2. The first column is the name of a certificate, the second is what the certificate to guarantee, and the third lists the data points involved in the certificate.

An event occurs when any certificate fails due to the distance change resulting from movement. Each event is in the form of (type, time, self, peer), where type represents the kind of its certificate; time is a future time instance when the event will happen; and self and peer respectively represent skyline point and relevant data point involved in the event.

Certificate sisj ensures for an existent volatile skyline point si that any other skyline point sj with the potential to dominate si (sj π si) keeps being farther to query point q than si, therefore si is not

# Table 2. Certificates

|Cert.|Objective|Data Points|
|---|---|---|
|sisj|∀si ∈ SKchg, sj ∈ SKall, s.t.|self = si sj π si → dist(q, si) < dist(q, sj) peer = sj|
|nspij|∀nspj ∈ SKall, ∀si ∈ SKall, s.t.|self = si si ≺ nspj → dist(q, si) ≤ dist(q, nspj)|
|ordij|∀si ∈ SKall, s.t.|self = si ∃sj ∈ SKall ∧ sj π si peer = sj ∧sj = si.next in Lsp → dist(q, si) < dist(q, sj)|

dominated by any of them and stays in the skyline. Here self and peer respectively point to si’s and sj’s entries in Lₛₚ.

Certificate nspij ensures for a non-skyline point nsp that all those skyline points currently dominating it keeps being closer to query point q than nsp, therefore nsp is prevented from entering the skyline. When a certificate of this kind fails at time, nsp will get closer to query point q than one skyline point si, but whether it will enter the skyline or not depends on whether si is the only one that used to dominate it. This will be checked when an event of this kind is being processed. Here self points to si’s entry in Lₛₚ, whereas peer is the tuple identifier of data point nsp.

Certificate ordij ensures for an existent skyline point si that its successor sj in Lₛₚ keeps being farther to query point q than it. This sj does not have the potential to dominate si, otherwise an sisj certificate will be used instead. Here self points to the entry of the predecessor skyline point in the pair, and peer to the successor. Certificate ordij not only keeps the order of all skyline points in Lₛₚ, but also implies a way to simplify event computation and evolvement. For Case 1 described in Section 3.2, it also involves a position exchange in Lₛₚ, i.e., just before sj dominating si, sj must be its successor. And we need to determine if an exchange in Lₛₚ really results in sisj event. In this sense, we only need to check for si its successor to compute a possible sisj or ordij event. If si does have an sisj or ordij event, the event’s time value is exactly si’s validity time tv. If si has no such event, its validity time is set to infinity. An event of certificate nspij with self = si is supposed to have a time stamp no later than si.tv, and those events with a later time are not considered.

Initially, Lsp contains the current skyline points, and Qe contains events that will happen in the nearest future. As time elapses, every due event is dequeued and processed based on its type. While processing due events and updating the skyline accordingly, our method also creates new events for future. Thus, Qe evolves with due events being dequeued and new events being enqueued, providing information for correctly maintaining the skyline. At any time t after all due events are processed, Lsp is the correct skyline with respect to the query point q’s current position.

# 4.2 Algorithms

For a given dataset, its SKns is pre-computed and stored as a system constant. Before maintaining skyline continuously, an initialization is invoked to compute the initial SKchg and the earliest events. To compute SKchg over static dataset for the query point’s starting position, in order to use the search bound determined by SKns and reduce intermediate steps to access data tuples when computing events, we use the grid file to index all data points. Grid file provides a regular partition of space and at most two-disk-access feature for any single record [17]. In our solution for the static dataset, we use a simple uniform 2D grid file dividing the data space into h × v cells to index D′, and the data points within each cell are stored in one disk page.

For the similar reasons we use a hash based method [24] to index moving data points in D′. The data space is also divided into regular cells, with each representing a bucket to hold all those moving data points within its extent. Data points can move across adjacent cells with the velocities in its tuple, which is monitored by a pre-processing layer and declared in an explicit update request to the database. An update request can also change a data point’s speed. How to deal with the updates of moving data points to maintain the correct skyline will be addressed in Section 4.2.1. Except for the difference on underlying indexing schemas, the initializations for static and moving datasets share the same framework and events creation algorithm.

The initialization framework is presented in Figure 6. First all permanent skyline points in SKns are inserted into Lsp according to their distance to query point q’s starting position. The farthest distance is recorded in variable dbnd as the search bound. Then starting from cell cellorg where q’s starting position

# Algorithm initialization(q)

Input: q is the query point

Output: the skyline for q’s starting position the event queue to be used in maintenance

// load SKns into skyline list

1. for each si in Skns
2. Compute a, b, c in terms of q;
3. Insert an entry (1, si, a, b, c, ∞,∞) into Lsp;

// search bound determined by SKns

dbnd = dist(Lsp.last, q);
compute initial skyline
Search the grid cell cellorg in which q lies;
while there still exist grid cells unsearched
for each cell celli on next outer surrounding circle
if (mindist(q, celli) ≥ dbnd)
break;
else Search celli;

// compute events

for each si from Lsp.last.prev to Lsp.first
createEvents(si, q);
handleBound(q, tcur);

Figure 6. Initialization framework lies, all grid cells are searched in a spiral manner that those on an inner surrounding circle are searched before those on an outer one. Cells beyond dbnd are pruned, where mindist is computed as in [22] by regarding a cell as an MBR. Points in a cell not pruned are sequentially compared to the current skyline points in Lₛₚ, which is adjusted with deletion or insertion if necessary. After all cells are searched or pruned, algorithm createEvents is invoked for each skyline point si from outermost to innermost, to compute all events for all skyline points except the last one sₗₐₛₜ. Finally, algorithm handleBound is called to compute a possible nspij event for those points farther than sₗₐₛₜ.

Algorithm handleBound is presented in Figure 7. It does not involve all outer non-skyline points of sₗₐₛₜ’s, instead it is limited to an estimated region. This region C is the difference between the two circles determined by sₗₐₛₜ and query point q at two different times, the current time and the earliest event time tₙₑₓₜ in the future. Only those non-skyline points in C have chance to enter the skyline before tₙₑₓₜ.

Algorithm createEvents is presented in Figure 8. For a given skyline point si in Lₛₚ, the algorithm first computes the time t when si and the next skyline point sj in Lₛₚ will exchange their position in

# Algorithm handleBound(q, tcur)

Input: q is the query point

Output: upcoming events for Lsp.last

1. tnext = Qe.first.time;
2. slast = Lsp.last;
3. C = Cir(q(tnext), slast) − Cir(q(tcur), slast)
4. for each point nsp in C
5. 1. for each sj from slast to Lsp.first
2. t = time nsp will get closer to q than sj;
3. if ((t ≥ sj.tv) or (t ≥ sj.tskip)) continue;
4. if (∀k, sj.pk ≤ nsp.pk)
5. Enqueue (sj, t, nsp, nspij) to Qe;
6. break;

Figure 7. Handle bound

the list, i.e. when sj will get closer to q than si. If t is later than sj’s skip time or si’s validity time, it is ignored. Otherwise, it means an sisj event depending on sj’s validity time if si ∈ SKchg, or it is a simple order change event. Then for each non-skyline point nsp between Cir(q, si) and Cir(q, sj), the algorithm computes nspij event by looping on all skyline points in the inner of nsp. Once an nsp event is derived, the loop on all inner skyline points breaks.

In maintaining the skyline, the due events are dequeued and processed according to its type, and new events are computed based on new positions. As in the initialization, the event of points out of the last skyline point is computed in a special way with an estimated search region by calling handleBound. The actions to process each kind of events are described as follows. For an sisj event, si is removed from the skyline and new events are computed for si’s predecessor because its successor skyline point in Lsp has been changed. For an nspij event, the non-skyline point nsp will be checked against all those skyline points closer to the query point, to see if they will enter the skyline. If not, a possible new nsp event is computed. Otherwise it will be added into the skyline and events will be computed for itself and its predecessor. For an ordij event the Lsp is correctly adjusted by switching si and sj, and events are computed for themselves and their predecessor.

19

# Algorithm createEvents(si, q)

Input: si is a skyline point in Lsp

q is the query point

Output: upcoming events for si

1. peer = null;

// compute events with next skyline point in Lsp
2. sj = si.next;
3. t = time si and sj will exchange position;
4. if ((t &lt; sj.tskip) and (t &lt; sj.tv))
5. if (!si.flag)
6. if ((t &lt; si.tv) and (∀k, sj.pk &lt;= si.pk))
7. si.tv = t; peer = sj;
8. else si.tskip = t;
9. // enqueue relevant events
10. if (peer = null)
11. Enqueue (si, si.tv, rep, sisj) to Qe;
12. if (si.tskip &lt; si.tv)
13. Enqueue (si, si.tskip, sj, ordij) to Qe;
14. // compute events involving non-skyline points
15. for each point nsp between Cir(q, si) and Cir(q, sj)
16. for each sk from si to Lsp.first
17. t = time nsp will get closer to q than sk;
18. if ((t ≥ sk.tv) or (t ≥ sk.tskip)) continue;
19. if (∀k, sk.pk &lt;= nsp.pk)
20. Enqueue (sk, t, nsp, nspij) to Qe;
21. break;

# Figure 8. Create events

# 4.2.1 Updating the Moving Plan

A moving data point mpti’s distance function does not change unless its moving plan changes. When this happens, the intersections of its distance function and other points’ will also be changed as a consequence, which invalidates those events computed based on mpti’s old distance function. Figure 9 shows how a data point’s velocity change causes the intersections of the function curves to change. Thus, it may cause the skyline to change in the future.

To ensure correct process with updates, we need to add for each moving object’s tuple a field tupt indicating its last update time. We define an update request for any moving data point mpti in the form update(id, x, y, vx, vy). id is mpti’s identifier which can be used to locate its tuple directly. x and y represent its current position. vx and vy represent its current speed. The algorithm updateMotion in

Figure 9. An example of the change of moving plan

Figure 10 is used to process such updates. When an update request comes in, it is first checked if mpti has moved to a new cell and if its speed has been changed since the last update. If x and y indicate that mpti has moved to a different cell, we need to remove it from the old one and insert it into the new one (line 1-5), which incurs 2 IOs. If vₓ and vy indicate that mpti’s speed is not changed, the algorithm stops (line 6-7). Otherwise, we need to update the speed record for mpti (line 8-10), and adjust relevant events starting from the first skyline points till the first one out of mpti (line 17). If mpti is a skyline point, then its events will be re-computed and the algorithm stops (line 12-15). Otherwise, the algorithm continues to compute nspi events for mpti (line 19-24). With the independent distribution assumption, (|SKₐₗₗ| + 1)/2 skyline points are expected to be accessed. To facilitate location of events involving a data point efficiently, the priority event queue is implemented using a B⁺-tree, and each current skyline point si has a list of pointers to all those events whose self is si.

It also can be seen in Figure 9 that right at the moment tupt when an update request comes in, the skyline does not change abruptly. To keep the skyline correct, the update request is only processed after all due events are processed, i.e., updateMotion(req) at time tupt executes after updateSkyline(tupt) completes.

# 4.3 Cost Analysis and Discussion

The space cost incurred by our method consists of two components: the space used to keep the skyline and that used to store events. For a d-dimensional dataset with N points subject to independent distribution, the expected size of its skyline is nsky = O((ln N)d−1) [5]. Since there are m static dimensions

# Algorithm updateMotion(req)

Input: req is an update request

Output: updated hash index, tuple and Qe

1. cell1 = T uple(req.id).cell;
2. cell2 = Hash(req.x, req.y);
3. if (cell1 = cell2)
4. 1. T uple(req.id).cell = cell2;
2. remove req.id from cell1 and insert it to cell2;

if ((req.vx == T uple(req.id).vx) and (req.vy == T uple(req.id).vy))
5. 1. return;

T uple(req.id).vx = req.vx
6. T uple(req.id).vy = req.vy
7. T uple(req.id).tupt = tcur
8. // Adjust relevant events

for each si in Lsp from Lsp.first
9. 1. if (si.tuple id == req.id)
2. 1. Delete all si’s events;
2. createEvents(si, q);
3. return;

Delete all si’s events with peer == req.id;
3. if (dist(q, T uple(req.id)) ≤ dist(q, si)) break;

nsp = req.id;
10. for each sj from si to Lsp.first

# Figure 10. Handle the change of moving plan

involved in skyline operator in our assumption in Section 2.1, the size of skyline on static dimensions is |SKₙₛ| = O((ln N)ᵐ−¹), and the size of skyline on all dimensions is |SKₐₗₗ| = O((ln N)ᵐ) at any time. Thus the size of changing part is |SKchg| = |SKₐₗₗ| − |SKₙₛ| = O((ln N)ᵐ − (ln N)ᵐ−1) at any time.

Now we consider the worst-case number of events, i.e., failure of certificates, at any time. In our method, any sisj event or ordij event is determined by an underlying intersection between two adjacent skyline points’ distance function curves. They are external events because they affect the skyline result we maintain [3]. Therefore, the maximum number of events of these two kinds is |SKₐₗₗ|ₘₐₓ/2, since we reduce multiplex intersections into simple ones and store only one at a time. In contrast, nspij events

are internal events because they are used to adjust internal data structure. As we at most keep one nspij event for a non-skyline point at any time, the worst case is that every non-skyline point is involved in such an event, which means the number of nspij events is not more than N − |SKₐₗₗ|ₘₐₓ. By summing up all events, the total number of events in the worst case is N − |SKₐₗₗ|ₘₐₓ/2. Hence, the ratio of total events to external events is 2N/|SKₐₗₗ|ₘₐₓ − 1. In the worst case where |SKₐₗₗ|ₘₐₓ is 1, the upper bound of this ratio is 2N − 1 which is linear with the number of all points involved. This worst case ratio verifies that our KDS is efficient.

As we store datasets in hard-disk, our method needs to do IO when accessing data points. The main IO cost is incurred by createEvents, which accesses all non-skyline points between the circles of two adjacent skyline points in Lₛₚ. This access can be regarded as a special region query over the dataset indexed by grid file, asking for points between two circles with same center but different radiuses. The IO cost of such a query can be estimated with a simple probabilistic model. Let the data space be a 2D unit space (as we use a 2D grid file to index all data points), and the outer and inner circles have radii Ri and ri respectively when we create events for the ith skyline in Lₛₚ. Then the area of the query circle is S = π(R² − r²), and the query will access SP = π(R² − r²)P grid cells (pages), where P is the total number of grid cells.

Next we estimate Ri, the distance from q to the i+1th skyline point in Lₛₚ. Suppose we do an incremental kNN search for q, if we have met i+1 permanent skyline points, then we must have met the the i+1th skyline point already. With the assumption of independent distribution, (i + 1)N/|SKₙₛ| points are met before the i+1th permanent skyline point. Then in the 2D unit space, we have πR² = ((i + 1)N/|SKₙₛ|)/N, which leads to an upper bound of Ri satisfying R² = (i+ 1)/(π|SKₙₛ|). For ri, which is the distance from query point q to the ith skyline point, we use a lower bound min(√(i/(π|SKₙₛ|)), √(i/(N − 1))) to approximate it. In this way, we get an upper bound of SP.

Let us compare the time cost of continuous skyline query to that of snapshot skyline queries. Assume N snapshot queries are triggered within a time period [t₁, t₂], and the cost of each is Ci. Then the total and average cost of that method are ∑ᴺ Ci and ∑ᴺ Ci/N respectively. More snapshot queries incur higher total processing cost, while each single snapshot query’s cost is expected to vary little from the average.

average cost C because of the static processing fashion. For the same time period, our method computes the initial skyline and events at time t₁, and then updates the skyline only when some certiﬁcate fails before t₂. Suppose the number of certiﬁcate failures during [t₁, t₂] is N′ (including the initialization), and the cost of each is C′, the total and average cost of our method are ∑ᴺ′ C′ and ∑ᴺ′ C ′/N ′ respectively.

The number of certiﬁcate failures N ′ is a constant in a ﬁxed time period, therefore the average cost C′ is determined by the total cost only. It makes little sense to compare the total costs of these two methods. If too many snapshot queries are triggered the total cost will be very high, while few snapshot queries deteriorate the result accuracy. To ensure a fair comparison of average costs, we set N = N ′ in our experiment. In other words, we trigger snapshot queries by assuming when the skyline changes is known, which is gained from our method. The experimental study results in next section show that our method even outperforms the privileged snapshot query method.

Our problem formulation assumes a linear movement model for both query point and data points (if they are moving), which is justiﬁed by the fact that linear movement model has so far been the most popular one in the literature of moving objects research [1, 12, 16]. This model itself assumes that moving objects hold their current velocities for a period of time, which is also usually considered as a system parameter in typical indexing structures such as TPR-tree [23] and Bˣ-tree [11]. In most cases, on the other hand, a user can change the speed but seldom changes it every time stamp while still issuing a continuous query. As long as the velocity keeps for a period of time, our method pays off because it saves much computation cost in the result maintenance for future, and it always reports result changes in time, which renders our method beneﬁcial.

# 4.4 Possible Extensions

It is true that users may issue continuous skyline queries with constraints in SQL WHERE clauses. Our current solution can be adapted to deal with such constraints with some modiﬁcations of the kinetic data structures (the certiﬁcate) to tender the WHERE clauses. In brief, we ﬁrst apply the given constraints to SKₙₛ so that an updated SK′ are gained for further use. Then, in the use of the kinetic data structures, only those data points satisfying the speciﬁed constraints will be considered and processed.

method is still effective to support the WHERE clauses. Our current method is focused on processing single continuous skyline query efficiently, whereas it still provides helpful indications for concurrent continuous skyline queries. |SKₙₛ| obviously is the common part for all concurrent queries, which means computation savings can be achieved with |SKₙₛ|. Besides, concurrent queries still can share volatile skyline points in some way. These indicate that with proper adaptations our current method can be used to handle this more complex case.

# 5 Experimental Evaluation

We conducted our experiments on a desktop PC running on MS Windows XP professional. The PC has a Pentium IV 2.6GHz CPU and 1GB memory. All experiments were coded in ANSI C++. The parameters used in the experiments are listed in Table 3. We used both static datasets and moving datasets. For the former, we explored into the effects of cardinality and non-spatial dimensionality on the performance. For the latter, we investigated into the effect of points speed distribution and moving plan update.

|Parameter|Setting|
|---|---|
|Dataset cardinality|100K, 200K, . . . , 1000K|
|Dimensionality of non-spatial attributes|2, 3, 4, 5|
|Distribution of non-spatial attributes|Independent, Anti-Correlated|
|Spatial range|10000 × 10000|
|Non-spatial attribute range|[0, 10000]|
|Point speed range|[10, 30]|
|Speed Zipf factor|0, 0.5, 1.0, 1.5, 2.0|
|Update interval|30, 60, 90, 120|
|Update ratio|4%, 6%, 8%, 10%|

# 5.1 Effect of Cardinality

In this set of experiments, we used synthetic datasets of data points with spatial attributes (x and y) and two non-spatial attributes. For each dataset, all data points are distributed randomly within the spatial space domain of 10, 000× 10, 000, and their non-spatial attribute values range from 1 to 100,000.

according to either independent or anti-correlated distribution. The cardinality of datasets ranges from 100K to 1M. For each set of data we executed 100 continuous queries moving in random directions. For each query, we randomly generated a point within the data space as the starting position of the moving query point. The speed of each moving query point is also randomly determined and ranges from 10 to 30. Each query ends as soon as the query point moves out of the data space extent. The minimum, maximum and average validity time for all these queries are 1, 475 and 149 units respectively. The experimental results to be reported are the average values on those 100 queries.

Since BBS algorithm is the most efﬁcient method for computing skyline in static settings (both dataset and query point are static) [18], we adapted it for comparison in our experiments. At each time instance, the BBS algorithm is invoked to re-compute the skyline in terms of the query point’s new position. Besides, we extended BBS algorithm to exploit the pre-computed static partial skyline points SKₙₛ for pruning, i.e., SKₙₛ is used in every call of BBS algorithm to prune more unqualiﬁed tree nodes and data points. In the result reports that follows, we use “BBS-Ex” to denote this method, in contrast to the pure BBS method. It is worth noting that both BBS based methods cannot correctly tell when the skyline changes as our method does.

The comparison was carried out on a fair basis. The same set of randomly generated queries are used by all methods on the same series of datasets. Processing costs, IO count and CPU time, in all methods are amortized over the same number of time units when the skyline changes. For both kinds of indices, R∗-tree and grid ﬁle, we set the data page size to 1K bytes.

# 5.1.1 Datasets of Independent Non-spatial Attribute Values

Figure 11(a) shows that as cardinality increases the logarithm of IO count of our maintenance method grows steadily, and nearly 2 orders of magnitude less than that of BBS. Figure 11(b) shows that as cardinality increases the CPU time cost of our maintenance solution grows steadily, in a rate much less than that of BBS. At each time instance, our maintenance solution does not need to search the whole dataset again to re-compute the skyline from scratch, instead it mainly involves event processing which consists less computation of distance and comparison of attribute values than BBS based methods.

# Figure 11. Effect of cardinality of independent datasets

| |IO count|Cardinality|CPU time (s)| | | |
|---|---|---|---|---|---|---|
| |100K|300K|500K|700K|900K| |
|10⁶ BBS|1.2 BBS|1.0 CSQ|10⁵|0.8|10⁴|0.6|
|10³|0.4|10²|0.2|0.0|10⁴|0.0|

160000 Maximum

Average

120 |SKₐₗₗ|

100 |SKₙₛ|

Due events

80

60

40

20

Event count and skyline size

|Cardinality|100K|300K|500K|700K|900K|
|---|---|---|---|---|---|
|(c) Event queue size| |(d) Skyline size and due events| | | |

which do a totally new search via R∗-tree. This processing behavior difference leads to the difference on processing costs. The improvement gained by BBS-Ex compared to pure BBS indicates that SKₙₛ does help pruning, nevertheless BBS-Ex cannot tell the skyline changes either.

Figure 11(c) shows the effect of cardinality on event queue size at any time unit. The maximum size is gained throughout all 100 queries. It can be seen that the queue event size increases as the cardinality increases, the average queue size is much smaller compared to the maximum size, and it does not exceed 6% of the cardinality.

Figure 11(d) shows the effect of cardinality on skyline size and the number of events being processed at any time unit. It can be seen that complete skyline size roughly increases as cardinality increases, but the average number of due events at any time unit of skyline change never exceeds 4, which indicates the efficiency of our maintenance strategy.

By comparing Figure 11(c) and 11(d) we can see that some events are not processed before the query ends. In a real application, we can take advantage of this observation to further reduce the queue size. The lifetime of a query can be estimated in a specific scenario, e.g., in 2 hours or this afternoon, and any event whose due time later than it will be prevented from being enqueued.

27

# 5.1.2 Datasets of Anti-Correlated Non-spatial Attribute Values

We also carried out experiments on datasets whose two non-spatial attributes are anti-correlated. We used the method in [6] to generate such datasets. Figure 12 shows our continuous skyline query processing still outperforms both BBS based methods. The higher cost than that on uniform datasets is attributed to the increase of skyline size of anti-correlated datasets. The anti-correlation between non-spatial attributes also makes the events number increases less unsteadily, as the dominance relationship of data points is more irregular compared to the independent datasets.

| |IO count|Cardinality| | | | |
|---|---|---|---|---|---|---|
| |100K|300K|500K|700K|900K| |
| |10⁶|BBS|BBS-Ex|CSQ| | |
| |10⁵| | | | | |
| |10⁴| | | | | |
| |10³| | | | | |
| |10²| | | | | |

| | |CPU time (s)|Cardinality| | | | |
|---|---|---|---|---|---|---|---|
| |100K|300K|500K|700K|900K| | |
| | |6.0|BBS|BBS-Ex|CSQ| | |
| | |5.0| | | | | |
| | |4.0| | | | | |
| | |3.0| | | | | |
| | |2.0| | | | | |
| | |1.0| | | | | |
| |0| | | | | | |

Figure 12. Effect of cardinality of anti-correlated datasets

# 5.2 Effect of Non-spatial Dimensionality

In this set of experiments, we used datasets of 500K points with non-spatial dimensionality ranging from two to five to evaluate the effect of non-spatial dimensionality on our solution. Values on those non-spatial dimensions are of independent distribution. Other settings are the same as in Section 5.1. Datasets with anti-correlated non-spatial values incur similar performance trends, except that every single cost is higher than its counterpart on the independent datasets. Hence we omit those figures here.

Figure 13(a)

and 13(b) show the IO and CPU cost respectively. Again our maintenance method outperforms the BBS based methods, and BBS-Ex is better than pure BBS.

Figure 13(c) shows that the event queue size decreases as the non-spatial dimensionality increases. The probability that one volatile skyline point will be dominated by others is lower when more dimensions are involved, because all dimensions are independent in our dataset. This reduces the number of events.

Figure 13(d) shows the effect of non-spatial dimensionality on skyline size and the number of events being processed at any time unit. It can be seen that both static partial skyline and complete skyline size increases as non-spatial dimensionality increases, but the average number of due events at any time unit is still drastically smaller. This indicates that our continuous query processing method still works efficiently.

| |IO count|Cardinality| | | | |
|---|---|---|---|---|---|---|
|2|3|4|5| | | |
|10⁶|BBS|BBS-Ex|CSQ| | | |
| |10⁵| | | | | |
| |10⁴| | | | | |
| |10³| | | | | |
| |10²| | | | | |

| | |CPU time (s)|Cardinality| | | | |
|---|---|---|---|---|---|---|---|
|2|3|4|5| | | | |
|3.0|BBS|BBS-Ex|CSQ| | | | |
| | |2.0| | | | | |
| | |1.0| | | | | |
| | |0.0| | | | | |

|Event count and skyline size|Cardinality| | | | |
|---|---|---|---|---|---|
|2|3|4|5| | |
|70000|Maximum| | | | |
|56000|Average| | | | |
|42000| | | | | |
|28000|Queue size| | | | |
|14000| | | | | |

Figure 13. Effect of non-spatial dimensionality

# 5.3 Effect of Movement Update

In this set of experiments, we used the dataset of 500K data points with spatial attributes (x and y) and two static non-spatial attributes. Every point in each dataset moves within the 2D extent with a speed

ranging from 10 to 30. The hash mechanism is based on the same grid file used for static datasets, with each cell as a bucket containing moving data points. Periodically, a number of moving data points send in update requests. Queries are picked up in the same way as in Section 5.1.

In this set of experiments, the initial speeds of all 500K points were uniformly distributed in the range of 10 to 30. We mainly explore into two aspects of moving data points update: update interval length and the ratio of points requesting update. We varied the update interval length from 30 to 120 time units and update ratio from 4% to 10%.

Figure 14(a) shows the IO count decreases as the update interval increases, and higher ratio of moving data update incurs more IO counts. Longer update interval reduces the amortized update cost which involves changing tuple and recomputing events, and weakens the effects of different update ratios. While higher update ratio increases update cost at every update time. The similar trend is seen for the CPU time shown in Figure 14(b).

| |IO count|Update interval| | |
|---|---|---|---|---|
|30|60|90|120| |
|10⁵|10%|8%|6%|4%|
|10⁴| |5| | |
|10³|3| | | |
|10²| | | | |

Figure 14. Effect of update

# 5.4 Effect of Speed Distribution

In this set of experiments, we fixed the moving data points update interval to 60, varied the update ratio from 4% to 10% to see the effect of initial speed distributions. The Zipf factor θ of speed distribution varies from 0, which is a uniform distribution, to 2, which is a skewed distribution where 80% data points move slowly and the 20% move fast. Other settings are the same as in Section 5.3.

Figure 15(a) shows that the IO cost of the proposed method is not too sensitive to skewness on speed. In Figure 15(b), CPU time increases slowly as θ increases from 0 to 1.5, and then decreases when θ

increases from 1.5 to 2. For the same θ, a higher ratio of mobility data set incurs a higher processing cost. The experiments show that our method performs well for the different distributions of moving speed.

|IO count| |CPU time (s)| | | | |
|---|---|---|---|---|---|---|
|10⁵|10⁴|10³|10²| | | |
| |10%|6|8%|6%|4%| |
| | |5|4| | | |
| |10%|4| | | | |

0     0.5     1     1.5      2    2 0      0.5     1       1.5      2

Zipf factor of speed distribution (θ)         Zipf factor of speed distribution (θ)

(a) IO                             (b) CPU time

Figure 15. Effect of speed distribution

# 6 Conclusion

In this paper, we have addressed the problem of continuous skyline query processing. The method, using the kinetic data structure, is based on the analysis that exploits the spatiotemporal coherence of the problem. Our solution does not need to compute the skyline from scratch at every time instance. Instead, the possible change from one time to another is predicted and processed accordingly, thus making the skyline query result updated and available continuously. The experimental studies conducted using different datasets and parameters demonstrate that the proposed method is robust and efficient. To the best of our knowledge, this is the first work on skyline queries in the moving context.

# References

[1] P. K. Agarwal, L. Arge, and J. Erickson. Indexing moving points. In PODS, pages 175–186, 2000.

[2] W.-T. Balke, U. Guentzer, and J. X. Zheng. Efficient distributed skylining for web information systems. In EDBT, pages 256–273, 2004.

[3] J. Basch, L. J. Guibas, and J. Hershberger. Data structures for mobile data. ACM SODA, pages 747–756, 1997.

# References

1. R. Benetis, C. Jensen, G. Karciauskas, and S. Saltenis. Nearest neighbor and reverse nearest neighbor queries for moving objects. In IDEAS, pages 44–53, 2002.
2. J. L. Bentley, H. T. Kung, M. Schkolnick, and C. D. Thompson. On the average number of maxima in a set of vectors and applications. Journal of ACM, 25(4):536–543, 1978.
3. S. Borzonyi, D. Kossmann, and K. Stocker. The skyline operator. In ICDE, pages 421–430, 2001.
4. J. Chomicki, P. Godfrey, J. Gryz, and D. Liang. Skyline with presorting. In ICDE, pages 717–816, 2003.
5. D. Hearn and M. P. Baker. Computer Graphics C Version. Prentice-Hall International, Inc., New Jersey, 1997.
6. G. Hjaltason and H. Samet. Distance browsing in spatial database. ACM TODS, 24(2):265–318, 1999.
7. G. S. Iwerks, H. Samet, and K. Smith. Continuous k-nearest neighbor queries for continuously moving points with updates. In VLDB, pages 512–523, 2003.
8. C. S. Jensen, D. Lin, and B. C. Ooi. Query and update efficient b+-tree based indexing of moving objects. In VLDB, pages 768–779, 2004.
9. G. Kollios, D. Gunopulos, and V. J. Tsotras. On indexing mobile objects. In PODS, pages 261–272, 1999.
10. D. Kossmann, F. Ramsak, and S. Rost. Shooting stars in the sky: An online algorithm for skyline queries. In VLDB, pages 275–286, 2002.
11. H. T. Kung, F. Luccio, and F. P. Preparata. On finding the maxima of a set of vectors. Journal of ACM, 22(4):469–476, 1975.
12. D. H. McLain. Drawing contours from arbitrary data points. Computer Journal, 17(4):318–324, 1974.
13. H. Mokhtar, J. Su, and O. Ibarra. On moving object queries. In PODS, pages 188–198, 2002.
14. J. Nievergelt and H. Hinterberger. The grid file: an adaptable, symmetric multikey file structure. ACM TODS, 9(1):38–71, 1984.
15. D. Papadias, Y. Tao, G. Fu, and B. Seeger. An optimal and progressive algorithm for skyline queries. In SIGMOD, pages 467–478, 2003.
16. D. Papadias, Y. Tao, G. Fu, and B. Seeger. Progressive skyline computation in database systems. ACM TODS, 30(1):41–82, 2005.
17. F. P. Preparata and M. I. Shamos. Computational Geometry: An Introduction. Springer-Verlag, 1985.
18. K. Raptopoulou, A. Papadopoulos, and Y. Manolopoulos. Fast nearest-neighbor query processing in moving-object databases. GeoInformatica, 7(2):113–137, 2003.

# References

1. N. Roussopoulos, S. Kelley, and F. Vincent. Nearest neighbor queries. In SIGMOD, pages 71–79, 1995.
2. S. Saltenis, C. S. Jensen, S. T. Leutenegger, and M. A. Lopez. Indexing the positions of continuously moving objects. In SIGMOD, pages 331–342, 2000.
3. Z. Song and N. Roussopoulos. Hashing moving objects. In MDM, pages 161–172, 2001.
4. R. E. Steuer. Multiple criteria optimization. Wiley, New York, 1986.
5. K. L. Tan, P. K. Eng, and B. C. Ooi. Efﬁcient progressive skyline computation. In VLDB, pages 301–310, 2001.
6. Y. Tao and D. Papadias. Time-parameterized queries in spatio-temporal databases. In SIGMOD, pages 334–345, 2002.
7. X. Xiong, M. F. Mokbel, W. G. Aref, S. E. Hambrusch, and S. Prabhakar. Scalable spatio-temporal continuous query processing for location-aware services. In SSDBM, pages 317–326, 2004.
8. J. Zhang, M. Zhu, D. Papadias, Y. Tao, and D. L. Lee. Location-based spatial queries. In SIGMOD Conference, pages 443–454, 2003.

